\chapter{Estado del Arte}

Como se ha explicado en los cap\'itulos previos, el objetivo del presente trabajo es presentar una arquitectura y herramientas que permitan la construcci\'on de \textit{APIs} sem\'anticas para datos enlazados.\\
Para alcanzar este objetivo se ha hecho imprescindible un estudio pormenorizado del estado del arte en lo referente a la arquitectura de \textit{APIs} de datos \textit{REST}, modelos formales para la definici\'on de sistemas distribuidos, avances en el desarrollo de la Web Sem\'antica, los \'ultimos avances alcanzados dentro de la iniciativa \textit{Open Linked Data} as\'i como de las herramientas y aplicaciones disponibles para implementar todos estos conceptos.\\

Algunas de estas \'areas de investigaci\'on se encuentran directamente relacionadas, como por ejemplo, las iniciativas \textit{Open Linked Data} y Web Sem\'antica, mientras que otras solo se encuentran relacionadas de forma indirecta, como los trabajos en arquitecturas de servicios web \textit{REST} que han influido de una forma directa en el desarrollo de muchas propuestas \textit{Open Linked Data}, pero en algunos casos, como en la relaci\'on entre la teor\'ia de la descripci\'on formal de sistemas distribuidos, su relaci\'on con las otras \'areas de investigaci\'on es mucho m\'as difusa. Esto supone que ideas importantes para el presente trabajo aparecen en diferentes autores con aproximaciones distintas, aunque complementarias, y diferentes terminolog\'ias. En este cap\'itulo intentaremos establecer estas relaciones entre las diferentes bases conceptuales sobre las que se ha construido esta tesis, as\'i como definir una terminolog\'ia com\'un que se utilizar\'a en el resto de este documento.\\

En la primera secci\'on de este cap\'itulo, revisaremos los \'ultimos avances en arquitecturas de servicios web \textit{REST}, y los conceptos b\'asicos sobre Web Sem\'antica que se encuentran en el germen del desarrollo de esta tesis. A continuaci\'on, se examinaran los trabajos sobre sistemas distribuidos que se han utilizado para realizar una descripci\'on formal de las arquitecturas \textit{REST} y por \'ultimo, los principales desarrollos de la comunidad \textit{Open Linked Data} en los que se trata de establecer puentes entre las tecnolog\'ias de la Web Sem\'antica y las arquitecturas de servicios \textit{REST}.\\

\section{Arquitecturas de servicios web \textit{REST}}

En los \'ultimos diez a\~nos, la visi\'on de la Web como una plataforma sobre la que desplegar aplicaciones distribuidas altamente desacopladas y extensibles, compuestas por una multitud de servicios web de datos, construidos sobre la pila de protocolos web (\textit{HTTP}/\textit{TCP}/\textit{IP}) ha suscitado el inter\'es tanto de la industria como de la comunidad de investigadores y que han sido com\'unmente englobados bajo el ep\'igrafe de \textit{SOA} (\textit{Service Oriented Architectures} o \textit{Arquitecturas Orientadas a Servicios}) \cite{soa}.\\
Un servicio web de datos en una arquitectura \textit{SOA} se puede definir como unidades funcionales, at\'omicas, desacopladas y que pueden ser invocadas a trav\'es del protocolo \textit{HTTP}. En la concepci\'on \textit{SOA} de las arquitecturas de servicios web, los servicios son interoperables gracias al uso de meta-datos, informaci\'on adicional sobre el servicio que describe la funcionalidad ofrecida por el servicio as\'i como los mensajes y el protocolo para acceder a ella.\\

Cuando la funcionalidad que se pretende alcanzar va m\'as all\'a del simple acceso a un servicio web para recuperar datos, involucrando un gran n\'umero de servicios interaccionando entre ellos y con los clientes web, aparecen problemas complejos que debe ser resueltos: como la composici\'on de un conjunto de servicios web para conseguir una determinada funcionalidad, problema conocido como \textit{orquestaci\'on de servicios web}, o de c\'omo automatizar la interacci\'on de un conjunto de servicios web sin un punto central de control, problema conocido \textit{como coreograf\'ia de servicios web}. \cite{orchestration_choreography}\\

Otros problemas asociados incluyen el catalogado de servicios web, as\'i como el \textit{descubrimiento de capacidades de servicios web} \cite{hoschek2002web} as\'i como los problemas de seguridad y autenticaci\'on en el acceso a dichos servicios.\\

La aproximaci\'on m\'as com\'un inicialmente, al conjunto de problemas que presentan las \textit{arquitecturas orientadas a servicios} entre la industria vino dado por un conjunto de est\'andares conocidos de forma gen\'erica como arquitecturas \textit{SOA WS-*} \cite{viering2009lacking}. 
Los componentes fundamentales de las arquitecturas \textit{SOA WS-*} consisten en un grupo de est\'andares entre los que se pueden destacar:\\

\begin{itemize}
\item \textbf{\textit{SOAP} (\textit{Simple Object Access Protocol}) \cite{soap}:} Un protocolo y formato de serializaci\'on de datos basado en \textit{XML} y que puede ser utilizado sobre una capa de transporte como HTTP o SMTP para el intercambio de datos estructurados.

\item \textbf{\textit{WSDL} (\textit{Web Services Description Language}) \cite{wsdl}:} Un lenguaje para la descripci\'on de la funcionalidad ofrecida por un servicio web, incluyendo la localizaci\'on del servicio, la forma de acceso y la descripci\'on, usando \textit{SOAP}, de los par\'ametros para su invocaci\'on as\'i como el tipo de datos devuelto.

\item \textbf{\textit{UDDI} (\textit{Universal Description Discovery and Integration}) \cite{uddi}:} Una propuesta de cat\'alogo de servicios web, construido sobre \textit{SOAP} y \textit{WSDL}, que puede ser usado por clientes web para encontrar y e invocar servicios web con el fin de llevar a cabo una determinada funcionalidad.
\end{itemize}


Sobre estos bloques b\'asicos, la comunidad \textit{WS-*} ha propuesto especificaciones m\'as complejas, que intentan solucionar algunos de los problemas anteriormente mencionados, como el de la coreograf\'ia de servicios web a trav\'es de la propuesta de est\'andar \textit{WS-CDL} (\textit{Web Services Choreography Description Language}) \cite{wscdl} o problemas tales como la descripci\'on formal y automatizable de la interacci\'on entre un determinado n\'umero de clientes y servicios web, expresada como un flujo de trabajo, para llevar a cabo alg\'un tipo de funcionalidad compleja, con est\'andares como \textit{WS-BPEL} (\textit{Business Process Execution Language}) \cite{wsbpel}. El objetivo \'ultimo que se persegu\'ia con la especificaci\'on de este conjunto de est\'andares era la descripci\'on de una arquitectura de distribuidos que se pudiese usar para la construcci\'on de aplicaciones empresariales complejos, siendo el caso paradigm\'atico la construcci\'on de sistemas \textit{ERPs} (\textit{Enterprise Resource Planner}) \cite{jian2008design}, \cite{li2009research}, conocida usualmente como \textit{Enterprise Service Bus} (ESB) \cite{esb}, por analog\'ia con el \textit{bus} de datos en las arquitecturas hardware, con un enfoque m\'as ligero, extensible y f\'acil de mantener que alternativas anteriores basadas en otras propuestas tecnol\'ogicas como CORBA, gracias a las caracter\'isticas de ocultaci\'on de la informaci\'on, alta cohesi\'on y bajo acoplamiento que te\'oricamente ofrecen los servicios web.\\

A medida que las implementaciones pr\'acticas de arquitecturas \textit{SOA} siguiendo los est\'andares \textit{WS-*} empezaron a hacerse realidad a mediados de la d\'ecada de los 2000. Los resultados obtenidos dieron pie a posiciones cr\'iticas sobre la viabilidad de las arquitecturas \textit{SOA} tal y como son concebidas por este cuerpo de est\'andares. Los principales inconvenientes se\~nalados se pueden desglosar as\'i:

\begin{itemize}

\item \textbf{Complejidad innecesaria:} las especificaciones \textit{WS-*} introducen un conjunto nuevo de formatos, protocolos, meta-servicios, etc. que  a\~naden una capa de complejidad elevada encima de la relativamente sencilla capa de aplicaci\'on \textit{HTTP}. Esta capa de complejidad hace que los sistemas \textit{SOA WS-*} sean costosos de desarrollar y mantener, necesitando casi de forma obligatoria herramientas de desarrollo autom\'aticas capaces de generar todo el c\'odigo intermedio requerido para realizar invocaciones a servicios o exponer incluso la m\'as sencilla de las funcionalidades como un servicio web de acuerdo con los est\'andares. Esto evita que algunas de las promesas que las arquitecturas \textit{SOA} promet\'ian, como la facilidad de reemplazar implementaciones de servicios, sean dif\'iciles de obtener en la pr\'actica. 

\item \textbf{Problemas de eficiencia}: la complejidad introducida por los protocolos \textit{SOA WS-*} influye en las decisiones concretas de implementaci\'on de los servicios web siguiendo dichos est\'andares. Por ejemplo, \textit{SOAP} describe el formato del mensaje que debe ser intercambiado entre cliente y servicio como un documento \textit{XML} complejo con un gran impacto en el tama\~no final en \textit{bytes} de los datos intercambiados, que se ven considerablemente incrementados. Esto supone que los servicios web \textit{WS-*} pueden ser menos eficientes desde el punto de vista computacional respecto a otras alternativas de implementaci\'on m\'as ad-hoc, como los servicios sencillos \textit{RPC} (\textit{Remote Procedure Invocation}) \cite{xmlrpc}, a pesar de ser estos \'ultimos menos gen\'ericos y extensibles.

\item \textbf{Alto acoplamiento entre clientes y servicios:} a pesar de que los servicios \textit{WS-*} en s\'i no dependen unos de otros, los clientes intentando acceder a un servicio en particular dependen completamente del protocolo de acceso a ese servicio, lo que conlleva que  cualquier cambio en los par\'ametros o tipos de entrada del servicio implican un cambio obligatorio del c\'odigo del cliente.

\end{itemize}

Sin embargo, la principal cr\'itica recibida por las arquitecturas \textit{SOA WS-*} vino dada por lo que se percibi\'o como una falta de congruencia entre la capa adicional que es a\~nadida por los est\'andares \textit{WS-*} sobre la capa web \textit{HTTP} y los principios de dise\~no de dicha capa web.\\
Este conjunto de principios arquitecturales se encuentran ya definidos en documentos como los \textit{Axioms of Web Architecture} de Tim Berners-Lee \cite{berners1997axioms}, pero fueron sistematizados en la tesis de Roy Fielding, \textit{Architectural Styles and the Design of Network-based Software Architectures} \cite{fielding2000representational}. En dicha tesis la arquitectura de la Web, basada en el protocolo \textit{HTTP}, aparece descrita en el cap\'itulo usando el acr\'onimo \textit{REST} (\textit{Representational State Transfer}). Las caracter\'isticas de las arquitecturas \textit{REST} tal y como aparecen descritas en la tesis de Fielding se enumeran a continuaci\'on:

\begin{itemize}
\item \textbf{Orientada a recursos:} el bloque b\'asico de la arquitectura \textit{REST} es el recurso, entendido como una relaci\'on conceptual entre identificadores y un conjunto de datos u otros identificadores asociados a ese identificador. La sem\'antica d esta relaci\'on conceptual debe permanecer constante a lo largo del tiempo, aunque los datos asociados puedan variar.

\item \textbf{Ausencia de estado mutable:} en la arquitectura \textit{REST}, el servicio no almacena informaci\'on sobre el estado del cliente entre peticiones. Esto supone una importante ventaja ya que permite que los sistemas web sean altamente escalables implementando componentes como cach\'es o aumentando el n\'umero de servidores ofreciendo un recurso particular sin necesidad de coordinar entre ellos estado mutable.

\item \textbf{Uso de identificadores est\'andar:} basados en ele est\'andar \textit{URL}, que se puede utilizar para designar de forma \'unica cualquier recurso expuesto a trav\'es de la Web.

\item \textbf{M\'ultiples representaciones y negociaci\'on de contenido}: cuando un cliente web intenta acceder a un recurso a trav\'es usando el \textit{URL} que lo identifica, cliente y servidor deben decidir que representaci\'on particular del estado actual de ese recurso va a ser obtenida por el cliente. Esta representaci\'on es conocida en la arquitectura \textit{REST} como \textit{media type} y puede contener los bytes asociados a los datos del recurso, as\'i como meta-datos sobre el recurso e incluso meta-datos sobre los meta-datos.

\item \textbf{Interfaz uniforme \textit{HTTP}:} en la arquitectura \textit{REST} la interfaz para acceder a los recursos expuestos es uniforme y con una sem\'antica est\'andar bien definida. Esta interfaz se compone de los m\'etodos disponibles en el protocolo \textit{HTTP}: \textit{GET}, \textit{POST}, \textit{PUT}, \textit{PATCH, }\textit{DELETE}, \textit{HEAD}, \textit{OPTIONS} y \textit{TRACE} a los que se les asigna la sem\'antica de operaciones para obtener un recurso, crearlos, actualizarlo, destruirlo y obtener informaci\'on asociada con \'el respectivamente.

\end{itemize}


La tabla \ref{restvsws} muestra las principales diferencias entre las propuestas arquitecturales \textit{REST} y \textit{WS-*}.\\
C\'omo se puede observar, las principales diferencias vienen dadas por diferencias en principios conceptuales b\'asicos entre ambos enfoques. Por un lado, la concepci\'on del servicio web como una invocaci\'on de una operaci\'on remota arbitraria, en el caso de los servicios \textit{WS-*}, frente al servicio web como una petici\'on \textit{HTTP} est\'andar para recuperar o modificar un recurso usando de una forma estricta la sem\'antica del protocolo \textit{HTTP} en el caso de los servicios \textit{REST}. En comparaci\'on, los servicios \textit{WS-*} usan una sem\'antica variable para las invocaciones \textit{HTTP}, que hace obligatoria la introducci\'on de meta-datos y meta-servicios adicionales como \textit{UDDI}, aumentando de esta medida la complejidad de la implementaci\'on de soluciones \textit{WS-*}.\\

El resultado \'ultimo de la aparici\'on de la propuesta arquitectural \textit{REST} en el panorama de las arquitecturas orientadas a servicios fue que diferentes sistemas de computaci\'on empresarial basadas en soluciones \textit{WS-*} empezaron a ser reemplazados por soluciones construidas usando servicios web \textit{REST}. Sin embargo, algunos patrones de integraci\'on en aplicaciones empresariales no son f\'acilmente traducibles usando los principios arquitect\'onicos \textit{REST}, como por ejemplo, la distribuci\'on as\'incrona y confiable de mensajes o los escenarios composici\'on de servicios y descripci\'on de flujos de procesos de negocio \cite{pautasso2008restful}. Para poder implementar algunos de estos casos de uso usando servicios web \textit{REST}, es necesario recurrir a est\'andares adicionales como \textit{WADL} \cite{wadl} para la descripci\'on de los recursos. En estos casos las soluciones \textit{WS-*} siguen siendo usadas profusamente.\\

Al mismo tiempo, la propia pila de protocolos y est\'andares \textit{WS-*} ha venido incorporando ideas y conceptos \textit{REST} con el fin de ofrecer soluciones m\'as simples y escalables, por ejemplo la versi\'on 2.0 de \textit{WSDL} introduce soporte para describir servicios \textit{WS-*} implementados sobre servicios web \textit{REST} \cite{takase2008definition}.\\

Fuera del \'ambito de la computaci\'on empresarial, a mediados de la d\'ecada de los 2000 y coincidiendo con el auge de la llamada Web Social o Web 2.0 \cite{murugesan2007understanding}, aparece la necesidad entre los desarrolladores de aplicaciones web de ofrecer el acceso a los datos almacenados en esas aplicaciones a los usuarios para que pudieran ser utilizadas por aplicaciones cliente m\'oviles, aplicaciones software de terceros o dispositivos hardware, como c\'amaras fotogr\'aficas. Tambi\'en empez\'o a ser importante la integraci\'on de datos de diferentes aplicaciones para ofrecer aplicaciones, conocidas como mashups, que ofrec\'ian una nueva funcionalidad a partir de la composici\'on de las diferentes fuentes de datos.\\

Esto supon\'ia ofrecer interfaces de servicios web, englobadas en una \textit{API} de datos, que pudiesen ser consumidas por los clientes web y otros servicios. Tras algunos intentos iniciales de utilizar \textit{APIs} basadas en algunos est\'andares \textit{WS-*}, como \textit{SOAP}, la arquitectura \textit{REST} se ha impuesto como el marco conceptual elegido por la mayor\'ia de aplicaciones Web 2.0 para implementar sus \textit{APIs} de datos, con mayor o menor grado de fidelidad a los principios prescritos por dicha arquitectura.\\

La  implementaci\'on en populares \textit{frameworks} desarrollo web como \textit{Ruby on Rails} o \textit{Django} de estos principios tambi\'en ha contribuido decisivamente a su difusi\'on.
La caracter\'isticas comunes de este tipo de \textit{APIs} de datos en aplicaciones web se enumeran a continuaci\'on:

\begin{itemize}

\item \textbf{Soporte parcial para la interfaz uniforme:} donde s\'olo los m\'etodos \textit{GET} y \textit{POST}, los \'unicos disponibles en los navegadores web, son incluidos en la interfaz de acceso, desplaz\'andose las operaciones asociadas al \textit{REST}o de operaciones de la interfaz \textit{HTTP} a \textit{URLs} especiales de la aplicaci\'on.

\item \textbf{Ausencia de negociaci\'on de contenido:} Muchas \textit{APIs} de datos no soportan m\'as que una sola representaci\'on de los recursos expuestos. Cuando m\'as de una representaci\'on est\'a disponible, la soluci\'on m\'as usada es el recurso a utilizar diferentes \textit{URLs} para diferentes representaciones, rompi\'endose de esta manera la identidad \'unica del recurso.

\item \textbf{Uso de JSON como un formato universal de intercambio:} La importancia de \textit{JavaScript} como el lenguaje nativo del navegador web, as\'i como la sencillez del formato, su eficiencia y la presencia de buenas bibliotecas para serializar y deserializar datos en otros lenguajes de programaci\'on han hecho que \textit{JSON} (\textit{JavaScript Simple Object Notation}), se haya convertido en el formato por defecto en la mayor\'ia de \textit{APIs} de datos, desplazando a otras opciones m\'as populares en el \'ambito de los servicios web \textit{WS-*} como \textit{XML}.

\item \textbf{Uso limitado de las capacidades m\'as avanzadas del protocolo \textit{HTTP}:} Caracter\'isticas propias del protocolo \textit{HTTP} como el uso de las cabeceras de \textit{cach\'e} son ignoradas y otras veces, es frecuente encontrar usos err\'oneos de las mismas, como en el caso de los c\'odigos de retorno de las peticiones \textit{HTTP} o el uso de la cabecera de localizaci\'on del recurso creado, muchas veces ignorados en favor del retorno del estado en el cuerpo de los datos recuperados.

\item \textbf{Conflictos en la identidad de los recursos entre \textit{URIs} e identificadores:} De acuerdo con los principios \textit{REST}, un recurso web deber\'ia venir asociado a un o m\'as de un \textit{URI} estable. Sin embargo, la mayor\'ia de \textit{APIs} identifican los recursos no por un \textit{URI} sino por un identificador que se introduce en la representaci\'on del recurso. Esto es debido a factores anteriormente comentados, como el uso de diferentes \textit{URLs} para designar diferentes representaciones de un mismo recursos.

\item \textbf{Uso de mecanismos ad-hoc para establecer enlaces entre recursos:} El uso de identificadores arbitrarios y relativos s\'olo a una determinada \textit{API} de datos, hace imposible para el cliente usar un mecanismo est\'andar como una \textit{URI} para identificar y obtener los recursos relacionados con un determinado recurso. Para obtener estos recursos, el cliente debe computar la \textit{URL} desde la que el recurso relacionado estar\'a disponible a partir de la informaci\'on de estado del recurso actual de una forma espec\'ifica a la \textit{API} en la que est\'an englobados.

\item \textbf{Dif\'icil inter-operabilidad entre \textit{APIs}:} Las dificultades para establecer enlaces entre recursos de una misma \textit{API} anteriormente comentadas, se hacen patentes tambi\'en de forma todav\'ia m\'as evidente cuando se intentan enlazar recursos entre \textit{APIs} de diferentes proveedores, si ambos proveedores no est\'an haciendo uso de \textit{URIs} can\'onicos para identificar los recursos o si estos \textit{URIs} no pueden ser insertados de una forma simple en la representaci\'on de los recursos.

\end{itemize}

Una consecuencia directa de las caracter\'isticas anteriormente expuestas, es que la mayor\'ia de \textit{APIs} existentes hoy en d\'ia se encuentran aisladas unas de otras. Los datos expuestos por los diferentes servicios y aplicaciones web a trav\'es de \textit{APIs} incompatibles y que no usan mecanismos est\'andar para identificar y describir los datos que ofrecen, y con ellos los usuarios de esos datos, se encuentran encerrados en silos de informaci\'on o \textit{walled gardens} \cite{halpin2008beyond} constituyendo islas de datos desde las que no se pueden establecer conexiones con otros servicios de datos. Esta situaci\'on es similar a la de la pl\'etora de redes locales aisladas en la \'epoca anterior al protocolo \textit{IP} de red y \textit{HTTP} de aplicaci\'on que almacenaban repositorios de documentos aislados unos de otros, en formatos incompatibles y sin ofrecer la posibilidad de establecer enlaces entre documentos situados en dos subredes diferentes.\\

La b\'usqueda de mecanismos que permitan el enlazado y la conexi\'on de \textit{APIs} ofrecidas por diferentes servicios, de tal forma que se pueda usar un mecanismo com\'un para la descripci\'on de los datos y la identificaci\'on de los recursos propios y remotos, facilit\'andose de esta manera el descubrimiento y la automatizaci\'on del consumo de servicios de datos ha sido el objeto de intensa investigaci\'on durante los \'ultimos a\~nos.
Algunas de las principales l\'ineas de investigaci\'on que se encuentran actualmente abiertas y que son relevantes para la presente tesis, se analizan a continuaci\'on.

\subsection{Descripci\'on de \textit{APIs} \textit{REST}}

Uno de los principales objetivos de dise\~no \textit{REST} es el de que los servicios web construidos deben ser auto-descriptivos \cite{berners1997axioms}. Esto quiere decir que un cliente que desee consumir un recurso a trav\'es de un servicio web \textit{REST}, deber\'ia obtener de forma automatizable, toda la informaci\'on necesaria para acceder al recurso o manipularlo, obtener diferentes representaciones del mismo a trav\'es del propio servicio usando meta-datos asociados con el recurso.\\

Debido a la simplicidad caracter\'istica de los servicios web \textit{REST}, as\'i como por el uso de convenciones como la sem\'antica asociada por el protocolo \textit{HTTP} a las operaciones del protocolo, el  \'unico mecanismo est\'andar disponible en la arquitectura \textit{HTTP} para describir las capacidades de un determinado servicio e intercambiar otros meta-datos sobe el servicio es el conjunto de cabeceras \textit{HTTP} intercambiadas por clientes y servicios, as\'i como los c\'odigos de respuesta establecidos en el protocolo.\\

 Estas cabeceras constituyen un mecanismo que puede ser usado de forma eficaz para descubrir informaci\'on sobre el servicio, como por ejemplo, en el mecanismo de negociaci\'on de contenido usando la cabecera de \textit{media type} asociada a un recurso. Adem\'as las cabeceras \textit{HTTP} son tambi\'en un mecanismo extensible, ya que nuevas cabeceras no recogidas en el est\'andar \textit{HTTP} puede ser incluidas como parte de una petici\'on de un cliente o en la respuesta proveniente de un servicio.\\

Sin embargo, el uso de cabeceras por s\'i s\'olo no resuelve completamente el problema de la construcci\'on de servicios auto-descriptivos, ya que constituye un mecanismo para el intercambio de meta-datos entre cliente y servicio pero no menciona como han de ser estos meta-datos, ni su formato, m\'as all\'a de los especificado por las diferentes versiones del protocolo \textit{HTTP}.
El problema se puede extrapolar a la descripci\'on de una \textit{API} completa, as\'i como la relaci\'on entre los recursos de esa \textit{API}.\\

En la actualidad este es un problema abierto. Actualmente la mayor\'ia de descripciones de \textit{APIs} \textit{REST} se realizan en texto plano, como documentaci\'on asociada al servicio que los desarrolladores del software que acceder\'a a dichos servicios deben interpretar y transformar en la l\'ogica de sus programas. Esta situaci\'on contrasta con los complejos mecanismos de descripci\'on de servicios web \textit{WS-*} que hacen muy recomendable el uso de herramientas autom\'aticas que generen el c\'odigo necesario para realizar las invocaciones pertinentes a los servicios que se desea consumir. \\

La forma de encontrar formas eficientes de describir servicios \textit{REST}, que puedan ser consumidas de forma autom\'atica por agentes software, sin incurrir en la complejidad asociada a los mecanismos de  descripci\'on de servicios \textit{WS-*} es todav\'ia un campo activo de investigaci\'on tanto a nivel acad\'emico como industrial.\\

Una primer tipo de soluci\'on a la descripci\'on de servicios web \textit{REST} ha consistido en la proposici\'on de diferentes lenguajes para la descripci\'on de recursos, como \textit{WADL} (\textit{Web Application Description Language}) \cite{wadl}, que propone una serializaci\'on \textit{XML} de la descripci\'on de los recursos de una \textit{API}, as\'i como de las operaciones, par\'ametros de entrada y c\'odigos de estado que ser\'an devueltos por los diferentes servicios de la \textit{API}. Esta descripci\'on pod\'ia ser expuesta como un recurso m\'as de la propia \textit{API} al que los clientes deben acceder para tener acceso al \textit{REST}o de recursos disponibles.\\

WADL supone una simplificaci\'on de mecanismos similares propuestos en el mundo de los servicios web \textit{WS-*} com \textit{WSDL}, y no ha conseguido el apoyo mayoritario de los desarrolladores de \textit{APIs} web \textit{REST}. El propio \textit{WSDL} en su versi\'on 2.0, permite la descripci\'on de servicios web \textit{REST}, como ya hemos mencionados, siendo esta versi\'on ligera de \textit{WSDL} mucho m\'as usado en la actualidad. Adem\'as de \textit{WADL}, otra gran cantidad de lenguajes de descripci\'on de servicios \textit{REST}, m\'as o menos ad-hoc y centrados en dominios concretos de aplicaci\'on han sido propuestos en la literatura sobre la materia. Entre ellos podemos citar \textit{RSWS} y \textit{WDL} \cite{lanthaler2010towards}.\\

Frente a los esfuerzos por especificar un lenguaje, m\'as simple que \textit{WSDL}, para la descripci\'on de servicios \textit{REST} que pueda ser usado de forma gen\'erica por los constructores de \textit{APIs} basadas en servicios \textit{REST}, una parte de la comunidad acad\'emica y de forma casi un\'anime la industria, ha argumentado que no existe la necesidad de un lenguaje de descripci\'on en absoluto.\\

La justificaci\'on a esta postura ha venido dada por la importante cantidad de informaci\'on acerca de la sem\'antica de los servicios que se puede obtener a partir de las convenciones propias de las arquitecturas \textit{REST}, como el uso de la interfaz uniforme \textit{HTTP} \cite{lanthaler2010towards}.\\

\subsection{Descubrimiento de servicios web \textit{REST}}

Un aspecto de gran importancia a la hora de implementar arquitecturas de servicios es la capacidad de descubrir autom\'aticamente los servicios necesarios para llevar a cabo una determinada funcionalidad. La principal opci\'on para el descubrimiento de servicios en el \'ambito de las arquitecturas de servicios web \textit{WS-*} la constituye \textit{UDDI} un registro centralizado de servicios, pensado para ser usado como un servicio de \textit{p\'aginas verdes} incluyendo detalles t\'ecnicos y de contacto sobre un determinado servicio.\\

\textit{UDDI} no ha encontrado una gran aceptaci\'on entre la industria, especialmente por su naturaleza centralizada as\'i como por su complejidad. La comunidad \textit{REST} ha intentando buscar en los \'ultimos a\~nos alternativas a sistemas como \textit{UDDI} que puedan usarse para descubrir servicios \textit{REST} sin incurrir en el complejo dise\~no de esta tecnolog\'ia. Algunas nuevas propuestas dentro de la comunidad de servicios web \textit{WS-*}, como \textit{WSIL} (\textit{Web Services Inspection Language} \cite{wsil} han intentado dar respuesta a las limitaciones de \textit{UDDI}, como por ejemplo, la arquitectura centralizada del servicio, pero sin conseguir a pesar de ello una importante aceptaci\'on.\\

Una de las soluciones exploradas ha sido el uso de un mecanismo fundamental en el dise\~no de la web como el sistema \textit{DNS} (\textit{Domain Name Service}) para aplicarlo al descubrimiento de servicios web \textit{REST} \cite{jara2012light} a trav\'es del uso de \textit{DNS-SD} una extensi\'on del est\'andar \textit{DNS} para el registro de servicios de un determinado tipo en un determinado dominio que pueden ser descubiertos por los clientes \textit{DNS}. La descripci\'on de los meta-datos del servicio se pueden incluir en un registro DNS de tipo TXT o SRV y conducir a trav\'es de una petici\'on \textit{HTTP} al servicio o a una descripci\'on del servicio usando alguno de los lenguajes de descripci\'on de servicios mencionados anteriormente. Este sistema supone algunas importantes ventajas sobre tecnolog\'ias como \textit{UDDI}: re-usa una tecnolog\'ia existente y aceptada por la industria, no es un sistema centralizado con lo que consigue una gran escalabilidad y es un sistema din\'amico donde nuevos servicios pueden registrarse y desregistrarse a medida que la computaci\'on evoluciona.\\

A pesar de las ventajas que una tecnolog\'ia como \textit{DNS} parece aportar como posible soluci\'on para el descubrimiento de servicios web, otra parte de la comunidad \textit{REST} ha intentado construir mecanismos para el descubrimiento de servicios sin hacer uso de elementos externos a la pila de tecnolog\'ias que conforman la web. Un ejemplo se encuentra en \cite{verborgh2011description}, donde se describe un algoritmo para realizar el descubrimiento de servicios web \textit{REST} con los que llevar a cabo una determinada tarea, partiendo de un enlace web inicial y utilizando para ello, la cabecera \textit{OPTIONS} del protocolo \textit{HTTP} como la forma con la que obtener los meta-datos asociados al servicio y el \textit{REST} o de cabeceras del protocolo \textit{HTTP} para negociar una posible representaci\'on o las capacidades asociadas al servicio.
Un modelo alternativo para el descubrimiento de servicios \textit{REST} descentralizado y basado puramente en tecnolog\'ias web que cumple con los est\'andares \textit{REST}, viene descrito en \cite{umbrich2009discovering}. En dicho modelo se distinguen tres capas principales: el conjunto de est\'andares web usados en el mecanismo de descubrimiento como \textit{URIs} y el protocolo \textit{HTTP}, una capa de referencia en la que se describe como, a partir de un determinado \textit{URI} se puede obtener la descripci\'on asociada a ese servicio y por \'ultimo la capa de descripci\'on, donde se investiga que vocabulario es el adecuado para especificar la descripci\'on del recurso.\\

Algunas de las propuestas de est\'andar que se han realizado para llevar a cabo la funcionalidad propia de la capa de referencia incluyen \textit{XLink} (\textit{XML Linking Language})  y \textit{LRDD} (\textit{Links based Resource Descriptor Discovery}) \cite{lrdd}. \textit{LRDD} describe mecanismos alternativos para asociar descriptores con los recursos descritos: uso de una etiqueta \textit{LINK} en la representaci\'on \textit{HTML} y \textit{Atom} de un recurso que enlazar\'ia al descriptor de ese recurso, el uso de una cabecera \textit{HTTP} denominada \textit{Link} que devolver\'ia el enlace a la descripci\'on del recurso cuando la \textit{URI} del recurso es desreferenciada usando una petici\'on \textit{HTTP} \textit{GET} o \textit{HEAD} y, por \'ultimo, el uso de un fichero \textit{.well-known} disponible en una localizaci\'on est\'andar para un dominio espec\'ifico y que incluir\'ia enlaces para las descripciones de los recursos disponibles en ese recurso.\\

\subsection{Flujos de trabajos y \textit{mashups} de servicios \textit{REST}}

En apartados anteriores hemos discutido los avances realizados en la descripci\'on de meta-informaci\'on acerca de recursos web, as\'i como de mecanismos que permitan el descubrimiento de dichos servicios. \\
La combinaci\'on de ambas l\'ineas de investigaci\'on abre la puerta a la automatizaci\'on de interacciones complejas entre agentes y servicios web, en lo que se conoce como ejecuci\'on de flujos de trabajo. Para llevar a cabo uno de estos flujos, los agentes deben descubrir, seleccionar y consumir servicios en un determinado orden de forma aut\'onoma siguiendo la gu\'ia ofrecida por una especificaci\'on de alto nivel donde se expone la l\'ogica de negocio que se quiere obtener. El proceso de transformar de una forma automatizada esta descripci\'on de la funcionalidad de negocio que se desea conseguir en un conjunto de interacciones entre servicios y agentes, se conoce como \textit{orquestaci\'on de servicios web} \cite{orchestration_choreography}.\\

Otro problema relacionado, aunque m\'as sencillo en su planteamiento es el la descripci\'on de interacciones entre servicios web a trav\'es de primitivas b\'asicas, como la composici\'on de servicios, que ser\'a luego ejecutada de una forma autom\'atica por parte de agentes software. Esta versi\'on del problema se conoce como \textit{coreograf\'ia de servicios web} \cite{orchestration_choreography}.\\

En el mundo de los servicios web \textit{WS-*}, dos est\'andares cubren ambas \'areas. \textit{WS-BPEL} (\textit{Business Processes Execution Language}) \cite{wsbpel} permite describir escenarios de orquestaci\'on de servicios web para que puedan ser luego ejecutados autom\'aticamente por un motor de ejecuci\'on de orquestaci\'on de servicios web. Por su parte \textit{WS-CDL} (\textit{Choreography Description Language}) \cite{wscdl} permite describir las operaciones b\'asicas que conforman la coreograf\'ia de servicios web para que puedan ser ejecutadas de una forma aut\'onoma por un agente software.\\
Un problema que ha sido abordado por diferentes autores es el de la integraci\'on de servicios web \textit{REST} con los est\'andares de coreograf\'ia y orquestaci\'on dise\~nados para los servicios web \textit{WS-*} [cite:Developing Web Services Coreography Standards – The case of \textit{REST} vs \textit{SOA}P].\\

Un primer paso para lograr esta integraci\'on ha venido dada por el soporte para servicios \textit{REST} en las \'ultimas versiones de \textit{WSDL} \cite{takase2008definition}, que es un componente esencial para las especificaciones tanto de coreograf\'ia \textit{WS-CDL}, como de orquestaci\'on \textit{WS-BPEL}.\\

Desde un punto de vista complementario tambi\'en se ha intentado modelar las primitivas b\'asicas de orquestaci\'on de un lenguaje como \textit{BPEL} a las primitivas b\'asicas de la interfaz uniforme \textit{HTTP} que caracteriza a los servicios web \textit{REST} \cite{pautasso2010restful}.\\

Por \'ultimo tambi\'en se han dise\~nado diferentes lenguajes de orquestaci\'on y coreograf\'ia espec\'ificamente pensados para ser utilizados en un entorno de servicios web \textit{REST}, entre los que pod\'iamos destacar: \textit{SWAP}, \textit{Wf-XML}, \textit{AWSP} y \textit{ASAP} \cite{zur2005developing}.\\

El inter\'es por integrar servicios web \textit{REST} en las soluciones de automatizaci\'on de flujos de trabajo \textit{WS-*}, ya sea desde la perspectiva de la orquestaci\'on o la coreograf\'ia, ha venido dada en la mayor\'ia de los casos por miembros de la industria que han invertido tecnol\'ogicamente en soluciones \textit{WS-*} y desean integrar el, cada vez m\'as rico, ecosistema de servicios web \textit{REST} dentro de su infraestructura. Sin embargo, dentro de la comunidad \textit{REST} y m\'as concretamente dentro de la comunidad de desarrollo web, existen problemas relacionados con la composici\'on de servicios web que han sido objetos de investigaci\'on tanto por la industria como en entornos acad\'emicos.\\

El caso m\'as paradigm\'atico es el de la construcci\'on de \textit{mashups} web \cite{mashups}. Se trata de un caso particular de orquestaci\'on de servicios, donde diferentes servicios \textit{REST} deben ser compuestos para obtener una funcionalidad web que ser\'a expuesta a un usuario. En la mayor\'ia de los casos el consumo y la integraci\'on de los recursos expuestos por los servicios \textit{REST} ser\'a autom\'atica, pero el dise\~no de la forma en que estos recursos servicios se agregar\'an estar\'a dirigida de una forma manual e interactiva por parte del usuario final a trav\'es de alg\'un tipo de interfaz web.

La mayor\'ia de soluciones descritas en la literatura consisten en herramientas creadas ad-hoc para ofrecer una determinada funcionalidad con mayor o menor grado de interactividad en la composici\'on del resultado de la agregaci\'on por parte del usuario final. Estas soluciones trabajan con un conjunto pre-determinado de servicios web \textit{REST} que no pueden ser modificados.\\

Algunas otras herramientas han intentado aportar un mayor grado de genericidad en la construcci\'on de \textit{mashups} explotando las caracter\'isticas de los servicios \textit{REST}, como la homogeneidad en el acceso a la informaci\'on. El trabajo m\'as destacado es el del \textit{Yahoo} con la construcci\'on de \textit{Yahoo Pipes} \cite{yahoo_pipes} una herramienta para la construcci\'on de \textit{mashups} web de una forma sencilla por parte del usuario final. La caracter\'istica m\'as interesante de Yahoo Pipes, reside en el uso de un meta servicio de datos capaz de adaptar cualquier servicio web que se ajuste a la interfaz uniforme \textit{HTTP} y que use \textit{JSON} como el formato de datos para la representaci\'on de los recursos expuestos. La interpretaci\'on de la sem\'antica de los datos \textit{JSON} obtenidos desde el servicio debe ser aportada por el usuario final construyendo la \textit{mashup} usando alguno de los elementos predefinidos que el sistema provee.\\

Por \'ultimo, otra aportaci\'on interesante en el desarrollo de \textit{mashups} web es el de la construcci\'on de lenguajes de programaci\'on o \textit{scripting} \cite{sabbouh2007web} espec\'ificamente dise\~nados para construir \textit{mashups} web a trav\'es de la integraci\'on de diferentes servicios \textit{REST}.\\

En dichos lenguajes, las operaciones primitivas que se pueden aplicar a un recurso \textit{REST} a trav\'es de la interfaz \textit{HTTP}, as\'i como la petici\'on de determinadas representaciones y las operaciones necesarias para agregar estas representaciones son transformadas en primitivas computacionales de alto nivel en el lenguaje de programaci\'on, de forma tal, que la composici\'on de servicios puede ser descrita de una forma sencilla a trav\'es del lenguaje de programaci\'on. Este programa puede ser a continuaci\'on ejecutado de forma autom\'aticamente por un agente software dotado de un interprete para dicho lenguaje de programaci\'on.\\

\subsection{\textit{HATEOAS}, \textit{Hypermedia} como el Motor del Estado de la Aplicaci\'on}

Un concepto clave que marca la diferencia entre el conjunto de especificaciones t\'ecnicas \textit{WS-*} y soluciones para la construcci\'on de servicios web basados en la invocaci\'on remota de procedimientos (\textit{RPC}) frente a los principios arquitecturales \textit{REST} es el del uso de los tipos de datos y los enlaces para mantener el estado de la aplicaci\'on.\\
Este concepto aparece ya en la tesis original sobre \textit{REST} de Roy Fielding \cite{fielding2000representational}, pero ha venido a consolidarse m\'as tarde bajo el acr\'onimo \textit{HATEOAS} (\textit{hypermedia} como el Motor del Estado de la Aplicaci\'on). La consecuencia b\'asica de este principio para la construcci\'on de \textit{APIs} de servicios web \textit{REST} es que la mayor\'ia de elementos del servicio, por ejemplo el protocolo de comunicaci\'on y su sem\'antica, debe ser fijos y est\'andar, en este caso el protocolo \textit{HTTP} y la sem\'antica predefinida para las operaciones del protocolo. El \'unico elemento sobre el que puede actuar el dise\~nador de la \textit{API} es sobre el tipo de datos asignado a las diferentes representaciones de los recursos expuestos.\\

Desde este principio de arquitectura, el dise\~no de \textit{APIs} es equivalente al dise\~no de tipos de datos, y conociendo como manipular un determinado tipo de datos, cualquier agente web deber\'ia ser capaz de utilizar una \textit{API} \textit{REST} partiendo de una \textit{URI} inicial, dado que el \textit{REST}o de elementos de la interfaz van a ser homog\'eneos y constantes respecto a cualquier otra \textit{API} \textit{REST}. Esto \'ultimo se logra a trav\'es de una segunda consecuencia b\'asica derivada del principio de dise\~no \textit{HATEOAS}, cualquier cambio en el estado de la aplicaci\'on se produce en el lado del cliente y es el resultado de seguir un enlace en la representaci\'on del recurso obtenida. De este modo, el servicio ofrece las opciones necesarias al cliente para que elija el siguiente estado de la aplicaci\'on de una forma est\'andar y el cliente debe limitarse a extraer estos enlaces, que tambi\'en pueden incluir otros elementos de control, como en un formulario \textit{HTML} y seleccionar el siguiente estado.\\

Una l\'inea de investigaci\'on fruct\'ifera dentro de la comunidad acad\'emica \textit{REST} ha consistido en la aplicaci\'on de las constricciones que el principio arquitect\'onico \textit{HATEOAS} impone a diferentes problemas en el desarrollo de servicios web. En la secci\'on anterior hemos visto como de forma impl\'icita \textit{HATEOAS} se ha intentado aplicar a la orquestaci\'on y coreograf\'ia de servicios web \textit{REST} a trav\'es del desarrollo de lenguajes espec\'ificos que ten\'ian en cuenta la presencia enlaces en las representaciones de los recursos para descubrir mecanismos para manipular dichos recursos o recursos asociados \cite{alarcon2011hypermedia}.\\
Otro ejemplo de la importancia de \textit{HATEOAS} para la definici\'on de servicios web \textit{REST} es evidente en la sucesi\'on de art\'iculos sobre como aplicar el principio \textit{HATEOAS} a \textit{APIs} ya existentes para transformarlas en \textit{APIs} consistentes con los principios arquitect\'onicos \textit{REST} tal y como se muestra en \cite{liskin2011teaching}.

\section{Web Sem\'antica}

La Web Sem\'antica ha recorrido un largo trayecto desde su concepci\'on hace m\'as de diez a\~nos por parte de Tim Berners Lee como una versi\'on de la web centrada en datos f\'acilmente procesables de forma automatizada por agentes software, en vez de una web \'unicamente de documentos para ser interpretados por usuarios humanos.\\

La visi\'on \'ultima de la Web Sem\'antica, en la que la inferencia l\'ogica jugar\'ia un papel destacado en la forma en que agentes software llevar\'ian a cabo tareas determinadas usando los datos disponibles en la web, no ha sido alcanzada en su totalidad. Sin embargo, en estos a\~nos de investigaci\'on, numerosos resultados, est\'andares y tecnolog\'ias relevantes para la investigaci\'on expuesta en esta tesis han sido desarrollados en el seno de la comunidad de investigaci\'on sobre Web Sem\'antica. 
En los siguientes apartados, se har\'a un repaso de los resultados m\'as importantes.

\subsection{Est\'andares Sem\'anticos}

La iniciativa Web Sem\'antica ha sido liderada y llevada a cabo en su mayor parte al amparo del consorcio Web (\textit{W3C}). Esto supone que la investigaci\'on m\'as importante sobre Web Sem\'antico ha cristalizado en el desarrollo de est\'andares web de la \textit{W3C}. Algunos de estos est\'andares han tenido una gran influencia, no s\'olo dentro de la comunidad Web Sem\'antica sino que ha tenido impacto en otras \'areas de investigaci\'on relacionadas y en la industria en algunos casos de uso en los que era necesario trabajar con datos estructurados.\\

Un primer est\'andar es \textit{RDF} (\textit{Resource Description Framework} o \textit{Framework} para la Descripci\'on de Recursos). \textit{RDF} describe simult\'aneamente un modelo de datos de una gran genericidad, consistente en un multi grafo dirigido, una serializaci\'on de dicho modelo de datos como una serie de expresiones sujeto-predicado-objeto y una sem\'antica precisa para dicho modelo de datos \cite{hayes2004rdf}.\\

\textit{RDF} se encuentra en el nivel m\'as b\'asico de la pila de est\'andares propuestos por la comunidad Web Sem\'antica, ya que es utilizado como el modelo de datos sobre el que se construyen el \textit{REST}o de est\'andares sem\'anticos.\\

Un grafo \textit{RDF} puede ser expresado usando diferentes sintaxis estandarizadas por la \textit{W3C}. La primera sintaxis propuesta estaba basada en \textit{XML} (sintaxis \textit{RDF/XML}) \cite{beckett2004rdf} y presenta una notable complejidad para los usuarios de dicha sintaxis, ya sea a la hora de generar la serializaci\'on de un grafo \textit{RDF} o a la hora de construir un \textit{parser} capaz de reconstruir un grafo \textit{RDF} a partir de un documento \textit{RDF/XML}. Un \'area de investigaci\'on destacable en estos a\~nos ha consistido en la b\'usqueda de mejores sintaxis para la serializaci\'on de grafos \textit{RDF}, teniendo como resultado algunas propuestas de sintaxis simples para \textit{RDF} como \textit{N3} \cite{n3} o \textit{Turtle} \cite{turtle}.\\

Otro est\'andar sem\'antico de gran importancia es \textit{SPARQL} (\textit{SPARQL Protocol and RDF Query Language}) \cite{sparql}, un lenguaje que permite realizar consultas sobre un grafo \textit{RDF} mediante expresiones consistentes en patrones de expresiones sujeto-predicado-objeto donde variables pueden ser intercaladas. \textit{SPARQL} es un lenguaje de consulta muy expresivo, que permite extraer partes de un grafo \textit{RDF} o informaci\'on particular de dicho grafo con una sintaxis similar a la de lenguajes de consulta para bases de datos relacionales como \textit{SQL}.\\
\textit{SPARQL} ha sufrido una evoluci\'on importante desde su especificaci\'on inicial. Se han elaborado resultados acerca de la sem\'antica formal y la complejidad computacional de las consultas \textit{SPARQL} \cite{perez2006semantics} y el est\'andar se ha extendido en su versi\'on \textit{SPARQL 1.1 UPDATE} \cite{sparql11} para dar soporte no solo a la recuperaci\'on de informaci\'on del grafo \textit{SPARQL}, sino a la modificaci\'on del grafo mediante consultas espec\'ificas para la actualizaci\'on, la inserci\'on y el borrado de tripletes en un grafo \textit{RDF}.\\

Otro conjunto clave de especificaciones sem\'anticas lo constituyen los lenguajes para definir ontolog\'ias sobre grafos \textit{RDF}. \textit{OWL} (\textit{Web Ontology Language}) \cite{owl} es el lenguaje est\'andar propuesto por la \textit{W3C} para la construcci\'on de vocabularios y ontolog\'ias con los que describir recursos web. \textit{OWL} extiende la sem\'antica propia de \textit{RDF} y de \textit{RDFS} (\textit{RDF schema}) \cite{rdfs} con primitivas ontol\'ogicas provenientes de la teor\'ia formal de la L\'ogica Descriptiva \cite{owl_dl_reduction}.\\
En la primera versi\'on del lenguaje, se especifican diferentes perfiles, que suponen un balance inverso entre expresividad, n\'umero de primitivas que se pueden usar en dicho perfil y complejidad algor\'itmica a la hora de llevar a cabo tareas de inferencia (clasificaci\'on, comprobaci\'on de consistencia, etc) sobre una ontolog\'ia expresada usando ese perfil. En la segunda versi\'on del lenguaje, \textit{OWL 2} \cite{owl2}, los perfiles se han reorganizando, asignando las primitivas en base a casos de uso particulares (\textit{QL}, \textit{EL}, \textit{RL}) \cite{owl2_profiles} y no tanto un incremento simple de menor a mayor complejidad y expresividad.
