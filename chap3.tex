\chapter{Descripci\'on de la Soluci\'on}

Nuestra meta en este cap\'itulo es analizar la capa de servicios web de una aplicaci\'on, desde la definici\'on formal de dicha interfaz hasta la implementaci\'on de herramientas y librer\'ias software que permitan el desarrollo de \textit{APIs} que combinen las tecnolog\'ias sem\'anticas con los principios arquitecturales web \textit{REST}, para ofrecer una alternativa pragm\'atica y viable a desarrolladores web que solucione las limitaciones de las que adolecen las t\'ecnicas actuales de desarrollo de \textit{APIs}.\\
Los principales elementos de este an\'alisis que se desarrollar\'an en este documento son los siguientes:\\

\begin{itemize}

\item \textbf{Modelo formal} de la capa de servicios web y agentes consumiendo dichos servicios, que constituye la interacci\'on b\'asica de cualquier \textit{API} de datos.

\item \textbf{Dise\~no de una soluci\'on arquitect\'onica} basada en los principios de arquitectura \textit{REST} que permita exponer datos enlazados en nuevas \textit{APIs} y servicios. Algunas de las caracter\'isticas con las que debe contar esta arquitectura pasan por la separaci\'on radical entre clientes y capa de servicio, el uso de la negociaci\'on de contenido para obtener la adecuada representaci\'on de los datos por parte del cliente, ser completamente agn\'ostica en cuanto al mecanismo de almacenamiento del grafo de datos enlazados usado en la implementaci\'on final y el uso del concepto de recurso web como la unidad fundamental de datos que son expuestos y agregados.

\item \textbf{Implementaci\'on componentes software} que permitan la f\'acil construcci\'on de aplicaciones clientes y servidores que consuman datos enlazados a trav\'es de la arquitectura para \textit{APIs} sem\'anticas anteriormente especificada. As\'i mismo tambi\'en se mostrar\'a c\'omo se pueden adaptar tecnolog\'ias  ampliamente usadas hoy en d\'ia para facilitar el almacenamiento de datos enlazados, de tal forma que puedan ser utilizadas como repositorios de datos para los recursos expuestos a trav\'es de la arquitectura para \textit{APIs} desarrollada.

\end{itemize}

La meta \'ultima de este trabajo es aplicar dichas tecnolog\'ias y herramientas a la construcci\'on de una aplicaci\'on web social, completamente descentralizada, donde la interconexi\'on de diferentes servicios asociados a distintos usuarios, controlando en todo momento los datos que generan as\'i como su identidad web, permita replicar la funcionalidad de las aplicaciones sociales centralizadas y dif\'icilmente inter-operables disponibles hoy en d\'ia. Los ejemplos de aplicaci\'on que describiremos abordan estos probelmas y servir\'an como validaci\'on de la aplicabilidad de la propuesta de modelo arquitect\'onico que hemos desarrollado.

\section{Model Formal}

Como hemos visto en los apartados del estado del arte relacionados con la construcci\'on de servicios web sem\'anticos, existen diferentes propuestas, para a\~nadir una capa sem\'antica a las \textit{APIs} de servicios web \textit{REST} expuestas por diferentes aplicaciones, por ejemplo, \textit{hRESTS} \cite{hrests} o \textit{SA-REST} \cite{sarest}. Sin embargo, estas propuestas se centran en detalles t\'ecnicos como diferentes t\'ecnicas de marcado sem\'antico y vocabularios espec\'ificos para describir los componentes esenciales de lo que supone el modelo \textit{REST} de servicios web sin ofrecer un verdadero modelo formal que permita describir soluciones computacionales a diferentes problemas, mediante el uso de servicios web \textit{REST} y meta-datos sem\'anticos. Dicho modelo, deber\'ia ser capaz de permitir dicha descripci\'on y servir de base sobre la que construir los diferentes componentes tecnol\'ogicos necesarios para implementar la soluci\'on descrita.\\
En este cap\'itulo propondremos un posible modelo formal que puede ser utilizado para describir de forma gen\'erica cualquier computaci\'on basada en el uso de servicios web \textit{REST} sem\'anticos.\\
Nuestro modelo se basa en dos referentes te\'oricos b\'asicos dentro del \'area de la computaci\'on distribuida:

\begin{itemize}
\item El uso de espacios de tripletes \cite{fensel2004triple} como un caso particular, adaptado al modelo de datos \textit{RDF} de los espacios de tuplas \cite{bussler2005minimal}, mecanismo de comunicaci\'on entre procesos mediante una memoria asociativa propuesto por Gelernter en sus art\'iculos sobre el sistem Linda \cite{linda}.

\item El C\'alculo Pi \cite{pi_calculus} un tipo de c\'alculo de procesos, en el que los procesos se comunican unos con otros a trav\'es del intercambio de mensajes a trav\'es de canales con nombre identificativo. Dichos mensajes pueden a su vez incluir los identificadores de los canales, con lo que los procesos pueden acceder a canales con los que comunicarse con nuevos procesos simplemente recibi\'endolos en un mensaje, variando de esta forma din\'amicamente con el tiempo la topolog\'ia de la red de canales y procesos que llevan a cabo una determinada computaci\'on.
\end{itemize}

El uso de estas dos bases te\'oricas en nuestra propuesta de c\'alculo formal es debida a la identificaci\'on de los componentes principales de la computaci\'on mediante servicios \textit{REST} con los componentes b\'asicos de los modelos de espacios de tripletes y el C\'alculo Pi.\\

Esta identificaci\'on se basa en los siguientes supuestos:
\begin{itemize}

\item Un recurso \textit{REST} sem\'antico consiste en un conjunto de tripletes \textit{RDF} almacenados en en un repositorio accesible por los procesos participando en la computaci\'on. Un recurso \textit{REST} sem\'antico consiste en un espacio de tripletes.

\item El espacio de tripletes que constituye el recurso \textit{REST} sem\'antico es accesible a trav\'es de un \textit{URI} asociado que puede ser enlazado desde otros recursos relacionados. Los \textit{URIs} asociados a los recursos se pueden considerar pues canales con identificadores como los que se usan los procesos del C\'alculo Pi para intercambiar mensajes.

\item El espacio de tripletes que que contiene los tripletes \textit{RDF} del recurso puede ser manipulado mediante peticiones \textit{HTTP} sobre el \textit{URI} asociado al recurso, de acuerdo con la sem\'antica propia de la interfaz uniforme \textit{HTTP}. De este modo, la sem\'antica de la interfaz \textit{HTTP} se puede traducir a las operaciones b\'asicas del C\'alculo Pi y por \'ultimo a las operaciones elementales sobre un espacio de tripletes.

\end{itemize}

Ejemplos de entornos de servicios web que cumplen estos supuestos son, servicios web en los que se intercambian documento \textit{HTML} con anotaciones sem\'anticas insertadas usando el est\'andar \textit{RDFa} o \textit{APIs} de servicios web que permiten a acceder a grafos \textit{RDF} almacenados en un repositorio de tripletes a trav\'es de una interfaz \textit{HTTP} \textit{REST}.\\
En los siguientes apartados explicaremos pormenorizadamente los detalles que permiten la identificaci\'on de un recurso \textit{REST} sem\'antico tanto con un espacio de tripletes como con un proceso dentro del C\'alculo Pi y que forman la base de nuestra propuesta de c\'alculo de procesos para servicios web sem\'anticos.

\subsection{Recursos sem\'anticos y espacios de tripletes}

La base del c\'alculo es la manipulaci\'on de meta-datos sem\'anticos representados como tripletes \textit{RDF}. Los componentes de un triplete pueden consistir en \textit{URIs} o literales. Cualquier computaci\'on descrita en el c\'alculo consiste en la manipulaci\'on de tripletes almacenados en espacios de datos compartidos denominados espacios de tripletes \cite{fensel2004triple} por un conjunto de procesos distribuidos.\\
Este modelo de computaci\'on distribuida se conoce como comunicaci\'on generativa de acuerdo con la terminolog\'ia propia de los sistemas de espacios de tuplas como Linda \cite{linda}. En estos sistemas se describe un conjunto finito de operaciones sobre el espacio de tuplas. Estas operaciones se pueden adaptar para manipular tripletes almacenados en un espacio de tripletes:

\begin{itemize}
\item \textbf{Rd:} Operaci\'on que permite leer tripletes del espacio de tripletes sin eliminarlos del repositorio. 
\item \textbf{Rdb:} Versi\'on bloqueante de la operaci\'on rd.
\item \textbf{In:} Operaci\'on que permite leer tripletes del espacio de tripletes elimin\'andolos del repositorio al mismo tiempo.
\item \textbf{Inb:} Versi\'on bloquente de la operaci\'on in.
\item \textbf{Out:} Operaci\'on que permite insertar tripletes en el espacio de tripletes.
\item \textbf{Notify \cite{busi2000process}:} Operaci\'on que permite a los procesos recibir una notificaci\'on cuando otros procesos manipulan el espacio de tripletes de una determinada manera.
\item \textbf{Swap \cite{bessani2008depspace}:} Operaci\'on que combina lectura, borrado y escritura en una sola operaci\'on at\'omica sobre el espacio de tripletes.

\end{itemize}

Las operaciones definidas en el c\'aculo sobre espacios de tripletes aceptan como argumentos tanto conjuntos de tripletes ($v$), como patrones ($p$). La sem\'antica particular del mecanismo de definici\'on de patrones y su aplicaci\'on sobre el espacio de tripletes puede variar sin afectar a la sem\'antica del c\'alculo. En este documento supondremos un mecanismo basado en un subconjunto de \textit{SPARQL} consistente s\'olo en la aplicaci\'on de patrones b\'asicos de grafo (\textbf{BGP}) con sustituci\'on simple de nombres \cite{sparql}.\\
Un patr\'on recibido en una operaci\'on puede ser aplicado a un conjunto de tripletes $(< p,v >$) o a un espacio de tripletes ($< p,\theta >$), obteni\'endose como resultado una colecci\'on de substituciones para las variables del patr\'on. Aplicando estas substituciones al patr\'on el conjunto de tripletes que satisfacen dicho patr\'on es obtenido finalmente. El resultado de la aplicaci\'on del patr\'on puede ser el conjunto vac\'io, si ninguna substituci\'on es obtenida.\\
Una definici\'on exacta de la sintaxis y sem\'antica operacional del c\'alculo, se pueden encontrar en las tablas \ref{tabla1} y \ref{tabla2}.\\

\begin{table}
\vspace{2.4in}
\caption{Sintaxis formal del calculo relativa al espacio de tripletes y elementos b\'asicos.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla1}
\label{tabla1}
\end{table}

La sem\'antica operacional del c\'alculo para la sintaxis formal aqu\'i introducida sigue formalizaciones anteriores propuestas para otros sistemas de espacios de tuplas de tipo Linda \cite{linda}. En particular, hemos elegido una sem\'antica con ordenaci\'on para las operaciones sobre el espacio de tripletes. Como consecuencia, la emisi\'on y aplicaci\'on de mensajes se puede considerar como una \'unica operaci\'on at\'omica. Se puede demostrar que los sistemas de tipo Linda con semanticas con con ordenaci\'on son Turing completos \cite{busi2000expressiveness}.\\

\begin{table}
\vspace{2.4in}
\caption{Sem\'antica operacional del calculo relativa al espacio de tripletes y operaciones b\'asicas.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla2}
\label{tabla2}
\end{table}

La sem\'antica operacional descrita en la tabla \ref{tabla2}, define una relaci\'on ($\rightarrow$) para las operaciones como la m\'as simple interpretaci\'on que satisface las reglas ($1$) â€“ ($10$). De \'estas, las comprendidas entre la regla ($4$)  y la regla ($6$) definen las principales operaciones sobre espacios de tripletes que modifican los tripletes almacenados.\\
La regla ($7$) muestra la sem\'antica de la operaci\'on \textit{swap} como una combinaci\'on en un s\'olo paso de reducci\'on de la sem\'antica de las operaciones \textit{in} y out. Por su parte, las reglas ($8$) y ($9$) definen las sem\'antica para la operaci\'on \textit{notify}. Mostrando su relaci\'on con las operaciones \textit{in}, \textit{out} y con el patr\'on pasado como argumento a la operaci\'on \textit{notify} aplicad a los tripletes insertados o eliminados por las operaciones \textit{in} y \textit{out}.\\

Como ya mencionamos, nuestra propuesta de c\'alculo se basa en la identificaci\'on de los elementos b\'asicos del modelo de servicios \textit{REST} con los axiomas formales introducidos en el modelo formal. Desde este punto de vista las siguientes identidades entre c\'alculo y m\'odelo \textit{REST}:

\begin{itemize}

\item Un conjunto de tripletes en un espacio de tripletes puede ser identificado como un recurso \textit{HTTP}.
\item Un identificador del espacio de tripletes puede hacerse equivalente a un \textit{URI} asociado a un recurso \textit{HTTP}.
\item Las operaciones \textit{GET} del protocolo \textit{HTTP} son equivalentes a operaciones \textit{rd} sobre el espacio de tripletes.
\item Las operaciones \textit{POST} del protocolo \textit{HTTP} son equivalentes a operaciones \textit{out} sobre el espacio de tripletes.
\item Las operaciones \textit{PUT} del protocolo \textit{HTTP} son equivalentes a operaciones \textit{swap} sobre el espacio de tripletes.
\item Las operaciones \textit{DELETE} del protocolo \textit{HTTP} son equivalentes a operaciones \textit{in} sobre el espacio de tripletes.

\end{itemize}

\subsection{Recursos sem\'anticos y procesos en tiempo de ejecuci\'on}

Las sintaxis y sem\'antica introducidas en el c\'alculo en el punto anterior y relativas a la visi\'on de los recursos \textit{HTTP} sem\'anticos como tripletes almacenados en un espacio de tripletes no es suficiente para describir una computaci\'on completa involucrando servicios web \textit{REST} sem\'anticos.\\
En primer lugar, en las concepciones originales de los espacios de tripletes, el espacio de tripletes era global, \'unico y compartido. Sin embargo, para modelar recursos \textit{REST} sem\'anticos, es conveniente considerar cada recurso individual como un espacio de tripletes diferente e identificado por un \textit{URI}. Del mismo modo, estos espacios de tripletes no ser\'ian est\'aticos, sino que podr\'ian ser creados mediante operaciones \textit{HTTP} \textit{POST} y destruidos mediante operaciones \textit{HTTP} \textit{DELETE}. La identificaci\'on de las operaciones \textit{in} y \textit{out} con los m\'etodos \textit{HTTP} \textit{DELETE} y \textit{POST} ser\'ia pues incompleta, ya que tendr\'ian como objeto tripletes individuales y no el conjunto del espacio de tripletes. El formalismo puede ser extendido \cite{simperl2007coordination} a\~nadiendo nuevas operaciones tanto sobre espacios de tripletes como sobre tripletes individuales. Teniendo en cuenta estas extensiones, los espacios de tripletes podr\'ian ser concebidos como procesos en el c\'alculo que pueden ser creados, recibir mensajes de otros procesos y terminar su ejecuci\'on.\\
Otra importante identidad entre servicios \textit{REST} y espacios de tripletes introducida ha sido la capacidad de asociar un \textit{URI} a un espacio de tripletes. De este modo, los procesos pueden ganar acceso a los tripletes de un recurso almacenados en un espacio de tripletes a trav\'es de los \textit{URIs} codificados en sus componentes. Desde este punto de vista, los espacios de tripletes pueden ser considerados no s\'olo procesos din\'amicos, sino como procesos m\'obiles tal y como los descritos en el C\'alculo Pi, ya que estos procesos podr\'ian coordinarse a trav\'es de canales con nombre (\textit{URI}) que se intercambiar\'ian dentro de los componentes incluidos en los mensajes (tripletes) enviados y recibidos por los procesos.\\
En las tablas \ref{tabla1} y \ref{tabla2} se definen la sintaxis y sem\'antica operacional que permite describir los espacios de tripletes como procesos din\'amicos mediante la definici\'on de la composici\'on paralela de procesos ($1$) as\'i como la congruencia estructural de procesos ($2$) \cite{pi_calculus}. Por su parte ($3$) define el proceso de creaci\'on de un nuevo proceso y por \'ultimo ($10$) define un tipo sencillo de ejecuci\'on condicional.\\
Adem\'as de estas primitivas para la creaci\'on y composici\'on de procesos, el c\'alculo debe ser extendido con nuevas operaciones, como las mostradas en la tabla \ref{tabla3}, que corresponden a variaciones de las operaciones descritas en el C\'alculo Pi Poli\'adico \cite{polyadic_pi}.\\

\begin{table}
\vspace{2.4in}
\caption{Sem\'antica operacional del c\'alculo relativa a la comunicaci\'on entre procesos.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla3}
\label{tabla3}
\end{table}

En dichas operaciones, los mensajes pueden ser enviados a trav\'es canales con nombre representados como \textit{URIs} ($\mu$). Los mensajes pueden ser de dos tipos, peticiones ($req$) o respuestas ($resp$) y los procesos pueden enviar y recibir ambos tipos de mensajes. A su vez, los mensajes se componen de un m\'etodo ($m$), un patr\'on ($p$) y un valor ($v$) en el caso de las peticiones y de un valor ($v$) y un c\'odigo ($c$) en el caso de las respuestas. Adicionalmente, tambi\'en se define una operaci\'on para introducir un nuevo identificador (\textit{URI}) en la computaci\'on. ($new\, \mu\, in\,P$).\\
La sem\'antica operacional para estas operaciones se introduce en la tabla \ref{tabla3} de acuerdo con la sem\'antica definida en el C\'alculo Pi Poli\'adico. Las reglas ($11$) y ($12$) son una adaptaci\'on a la sintaxis de nuestro c\'alculo de la regla de comunicaci\'on del C\'alculo Pi, mostrando la reacci\'on entre procesos enviando y recibiendo mensajes. Las reglas ($13$) y ($14$), imponen restricciones sobre el orden en que peticiones y respuestas deben ser intercambiados. Seg\'un la sem\'antica definida, sin un proceso env\'ia un mensaje con una petici\'on a otro proceso, debe esperar un mensaje con una respuesta  tras un n\'umero finito de reducciones a trav\'es del mismo \textit{URI}. De modo sim\'etrico, si un proceso recibe una petici\'on a trav\'es de un \textit{URI} debe enviar una respuesta tras un cierto n\'umero de reducciones.

Esta sem\'antica permite modelar de una forma m\'as \'util en el c\'alculo las peticiones \textit{HTTP} a recursos \textit{REST} sem\'anticos como mensajes de petici\'on enviados a procesos a trav\'es de canales definidos como \textit{URIs} a recursos \textit{REST}. Estos mensajes consisten en un m\'etodo m\'as un patr\'on o tripletes y la respuestas vendr\'ian dadas por un c\'odigo de respuesta m\'as un conjunto de tripletes. Es posible crear nuevos recursos \textit{REST} sem\'anticos como resultado de peticiones POST asociados a nuevos \textit{URIs} introducidos en la computaci\'on y su ejecuci\'on podr\'ia terminar como resultado de una petici\'on DELETE. El sistema compuesto por estos recursos \textit{REST} sem\'anticos ser\'ia un c\'alculo de procesos m\'obiles dado que en los mensajes de respuesta provenientes de un recurso, podr\'ian encontrarse \textit{URIs} asociados a diferentes recursos.

\subsection{Modelado de recursos \textit{REST} sem\'anticos}

En las dos secciones previas, hemos introducido la notaci\'on y la sem\'antica de nuestro c\'alculo que permiten la descripci\'on de los recursos \textit{REST} sem\'anticos usando dos formalismos diferentes, los espacios de tripletes y el c\'alculo de procesos m\'oviles. Ambos mecanismos son complementarios siendo cada uno m\'as adecuado para la descripci\'on de diferentes aspectos de la computaci\'on con recursos \textit{REST} sem\'anticos. Los espacios de tripletes ofrecen una excelente descripci\'on de los recursos \textit{REST} sem\'anticos como repositorios est\'aticos de datos sem\'anticos, usando operaciones sobre los datos sem\'anticos como el principal mecanismo de coordinaci\'on entre los procesos manipulando dichos repositorios. De modo similar, el c\'alculo de procesos es adecuado para describir los aspectos din\'amicos del  protocolo \textit{HTTP}, como el mecanismo de paso de mensajes a trav\'es de canales con nombres, asociados a \textit{URIs}, entre procesos agentes y procesos que constituyen los recursos \textit{REST} sem\'anticos.\\
En esta secci\'on una se define formalmente de una forma definitiva el concepto de recurso \textit{REST} sem\'antico, que combina aspectos de ambos formalismos, usando para ello la sintaxis y la sem\'antica introducidas en las secciones anteriores.\\

Las principales caracter\'isticas de esta formalizaci\'on de la computaci\'on basada en recursos \textit{REST} sem\'anticos se enumeran a continuaci\'on:\\

\begin{itemize}
\item Cualquier computaci\'on es llevada a cabo por procesos distribuidos: agentes y recursos.
\item Cualquier proceso tiene un n\'umero de espacios de tripletes asociados que pueden ser manipulados por las operaciones sobre espacios de tripletes introducidas en la secci\'on 3.1.1.
\item Un cierto n\'umero de procesos compartiendo el acceso al mismo espacio de tripletes se pueden agrupar en una localizaci\'on computacional. Una aplicaci\'on web compuesta de multiples recursos web es un ejemplo de localizaci\'on computacional. Un navegador web ser\'ia otro ejemplo de localizaci\'on computacional compuesta \'unicamente de procesos agente.
\item Los procesos recurso tienen al menos un canal con nombre asociado (\textit{URI}) por el que pueden recibir mensajes de tipo petici\'on (req) enviados por otros procesos.
\item Los procesos agente no tienen un canal con nombre asociado (\textit{URI}), por lo que no pueden recibir mensajes de tipo petici\'on, pero pueden enviar mensajes de tipo petici\'on y recibir respuesta (resp) a procesos de tipo recurso a trav\'es de las \textit{URIs} almacenadas en sus espacios de tripletes.
\item La coordinaci\'on entre los procesos dentro de la misma localizaci\'on de computaci\'on se basa en las operaciones y sem\'antica definidas en el c\'alculo para las operaciones sobre espacios de tripletes.
\item Los canales con nombres (\textit{URIs}) pueden ser intercambiados a trav\'es de mensajes de petici\'on y respuesta y almacenados en espacios de tripletes como parte de los componentes de los tripletes.
\item La \'unica coordinaci\'on posible entre procesos en diferentes localizaciones de computaci\'on se basa en el paso de mensajes petici\'on y respuesta a trav\'es de canales con nombres (\textit{URIs}). Los identificadores de los espacios de tripletes no pueden ser intercambiados a trav\'es de mensajes petici\'on y respuesta.
\end{itemize}

Usando este modelo, una posible formalizaci\'on param\'etrica de un proceso sem\'antico \textit{REST} $S_{REST}(\theta,\mu)$, con un espacio de tripletes asociado ($\theta$), identificado por un \textit{URI} ($\mu$)  y que sigue la sem\'antica de la interfaz homog\'enea \textit{REST}, se muestra en la Tabla \ref{tabla4}.\\

\begin{table}
\vspace{2.4in}
\caption{Descripci\'on param\'etrica de un recurso \textit{REST} sem\'antico simple.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla4}
\label{tabla4}
\end{table}


Seg\'un esta descripci\'on, el proceso recurso recibe un mensaje de tipo petici\'on y comprueba el tipo de la operaci\'on del mensaje.
Si es una petici\'on de tipo \textit{GET} incluyendo un patr\'on $p$, utiliza una operaci\'on sobre el espacio de tripletes $rd$ para leer sin extraer los tripletes que satisfagan el patr\'on y enviarlos a trav\'es de su \textit{URI} asociado al proceso que realiz\'o la petici\'on a trav\'es de un mensaje de tipo respuesta.\\
Si la petici\'on es de tipo \textit{POST}, incluyendo un patr\'on p con una \'unica variable, el proceso genera un nuevo \textit{URI} $\mu$ y lo aplica al patr\'on para obtener un nuevo conjunto de tripletes que escribe en su espacio de tripletes asociado $\theta$. Por \'ultimo un nuevo proceso recurso para los tripletes, espacio de tripletes y \textit{URI} asociada es iniciado por el proceso antes generar el mensaje respuesta al proceso que inici\'o la petici\'on.\\
Las peticiones \textit{PUT} son definidas a trav\'es de una operaci\'on \textit{swap} en la que se aplica el patr\'on y los nuevos valores contenidos en la petici\'on enviada por un proceso cliente a los tripletes almacenados en el espacio de tripletes. Las peticiones \textit{DELETE} por su parte, suponen la finalizaci\'on de la ejecuci\'on del proceso y el borrado del espacio de tripletes asociado de todos los tripletes asociados al \textit{URI} identificador del recurso.\\
La Figura \ref{figura1} muestra una representaci\'on gr\'afica de un posible modelo de ejecuci\'on de computaci\'on sem\'antica. Dicho modelo se compone de tres dominios que constituyen cada uno una localizaci\'on de computaci\'on independiente con su espacio de tripletes.\\

\begin{figure}
\vspace{2.4in}
\centering
\caption{Ejemplo de computaci\'on \textit{REST} sem\'antica.}
\vspace{5mm}
\includegraphics[width=0.5\textwidth]{figura1}
\label{figura1}
\end{figure}

Cada uno de ellos da soporte a un proceso recurso identificado por los \textit{URIs} 1, 2 y 3. Adem\'as, la localizaci\'on de computaci\'on constituida por el \textit{dominio-2} incluye tambi\'en un proceso agente capaz de comunicarse con el servicio en el \textit{dominio-3} a trav\'es del \textit{URI} 3 almacenado en el espacio de tripletes presente en el \textit{dominio-2}. La figura tambi\'en muestra una localizaci\'on de computaci\'on adicional, que modela una aplicaci\'on web conectada con su propio espacio de tripletes y dos procesos agente. Dichos procesos agente pueden enviar mensajes de petici\'on a los servicios en los dominios 1 y 2 a trav\'es de las \textit{URIs} 1 y 2 almacenadas en el espacio de tripletes de la aplicaci\'on cliente. Por su parte el proceso recurso y el proceso agente localizado en el dominio-2 pueden coordinarse a trav\'es de operaciones sobre el espacio de tripletes del dominio,  por ejemplo a trav\'es de una operaci\'on \textit{notify}, de tal modo que si el proceso recurso recibe un determinado mensaje de petici\'on, esto desencadene una notificaci\'on en el cliente para que pueda realizar una operaci\'on como reacci\'on, por ejemplo, enviar un mensaje de petici\'on al proceso recurso en el \textit{dominio-3}.

\section{Modelo arquitect\'onico}

En la secci\'on previa, se ha introducido un modelo formal que puede ser empleado para describir rigurosamente una computaci\'on basada en recursos \textit{REST} sem\'anticos.
Sin embargo, para transformar este modelo te\'orico en una implementaci\'on concreta de la soluci\'on, es necesario contar con un modelo de arquitectura software que sea consistente con las primitivas formales del c\'alculo descrito, definiendo al mismo tiempo las tecnolog\'ias y principales componentes con los que debe contar un sistema software que pretenda transformar dicho modelo formal en c\'odigo ejecutable.\\
En esta secci\'on describiremos este modelo arquitect\'onico, mediante la presentaci\'on de una ontolog\'ia \textit{RDF Schema} (\textit{RDFS}) que describe un modelo de servicios web que pueden dar soporte a las operaciones te\'oricas del c\'alculo de recursos \textit{REST} sem\'anticos discutido anteriormente y que sigue, al mismo tiempo, los principios arquitect\'onicos propuestos por la comunidad de Datos Enlazados Abiertos. Cualquier implementaci\'on de la arquitectura de servicios web \textit{REST} sem\'anticos que proponemos deber\'ia ser capaz de procesar autom\'aticamente una descripci\'on de una \textit{API} en los t\'erminos de la ontolog\'ia \textit{RDF} que proponemos y trasformarla en una serie de procesos software en tiempo de ejecuci\'on que ofrezcan los servicios especificados en dicha descripci\'on.\\
Los \'unicos componentes software que se presuponen es alg\'un tipo de adaptador \textit{HTTP} capaz de recibir en una interfaz de red peticiones en este protocolo, y un repositorio de grafos \textit{RDF} que soporte el lenguaje de consultas \textit{SPARQL 1.1 Update}. Esta versi\'on del lenguaje \textit{SPARQL} incluye no solo operaciones para recuperar informaci\'on desde el grafo \textit{RDF}, sino tambi\'en para modificar y eliminar tripletes del grafo.
El modelo arquitect\'onico de servicios web \textit{REST} sem\'anticos que vamos a describir, cumple con los siguientes requisitos fundamentales:

\begin{itemize}
\item Debe ser una alternativa viable para el desarrollo de \textit{APIs} de servicios web para el tipo de aplicaciones web que se desarrollan en la actualidad. A la hora de introducir nuevas tecnolog\'ias o conceptos, debe intentar hacerlo de una manera que resulte lo m\'as familiar posible para los desarrolladores web no familiarizados con las tecnolog\'ias estandarizadas por la comunidad Web Sem\'antica y Datos Enlazados Abiertos.
\item Debe permitir llevar a cabo una implementaci\'on software del c\'alculo formal de recursos \textit{REST} sem\'antico mostrado en la secci\'on previa de este documento.
\item Debe cumplir con los principios arquitecturales \textit{REST} y las recomendaciones de dise\~no originadas en la comunidad de Datos Enlazados Abiertos.
\item Debe dar soporte, no s\'olo a la recuperaci\'on de datos, sino tambi\'en a la creaci\'on, actualizaci\'on y eliminaci\'on de recursos.
\item Debe intentar, dentro lo posible, reutilizar el trabajo y los vocabularios ya existentes dentro de la comunidad de Datos Enlazados Abiertos.
\end{itemize}

Dentro de las posible alternativas para la construcci\'on de una \textit{API} de servicios web para el acceso a grafos \textit{RDF} que mencionamos en apartados previos de este documento, la \textit{API} que vamos a describir se basa en el intercambio de grafos \textit{RDF} a trav\'es del protocolo \textit{HTTP}, tal y como establece la propuesta de recomendaci\'on de la \textit{W3C} para un  Protocolo \textit{SPARQL} \textit{HTTP} Uniforme para la Gesti\'on de Grafos \textit{RDF} \cite{ogbuji2011sparql}. Usando este protocolo, los recursos de informaci\'on en el servicio pueden ser descritos como tripletes almacenados en un \textit{grafo con nombre}. Esta concepci\'on de los recursos expuestos en la \textit{API} tambi\'en coincide con el concepto de recurso \textit{REST} sem\'antico descrito en el c\'alculo formal de recursos \textit{REST} sem\'anticos descrito anteriormente en este documento, donde  los tripletes de cada \textit{grafo con nombre} ser\'ian equivalentes al espacio de tripletes que respalda al proceso del c\'alculo que ofrece la funcionalidad \textit{REST} b\'asica y la \textit{URI} del \textit{grafo con nombre} har\'ia las veces del canal con nombre por el que los procesos agentes tendr\'ian acceso a los tripletes del recurso.
El uso de grafos con nombre como base para la definici\'on de recurso en la \textit{API} ofrece un nivel de granularidad similar al de otras \textit{APIs} \textit{REST} \cite{wilde2009restful}.\\
De forma adicional, introduciremos algunas caracter\'isticas convenientes que normalmente pueden encontrarse en \textit{APIs} basadas en entidades atributo-valor, como la propuesta LD-API \cite{ld_api} con el fin de facilitar el uso de la \textit{API} a clientes web con restricciones, como navegadores web.

\subsection{Declaraci\'on de recursos enlazados}

En la tabla \ref{tabla5} se encuentra la descripci\'on \textit{RDF} de un ejemplo de servicio web \textit{REST} sem\'antico, que se almacenar\'a en una base de datos relacional, de acuerdo con el modelo de servicio web que proponemos.\\

% \begin{table}
% \vspace{2.4in}
% \caption{Descripci\'on \textit{RDF} de un servicio \textit{REST} sem\'antico.}
% \includegraphics[width=0.8\textwidth]{tabla5}
% \label{tabla5}
% \end{table}

\lstset{caption=Descripci\'on \textit{RDF} de un servicio \textit{REST} sem\'antico.,label=tabla5, captionpos=b,basicstyle=\small}
\begin{lstlisting}
@prefix testblog: <http://example.org/blog#> .
@prefix lda: <http://restful_linked_data_api.org#> .
@prefix api: <http://purl.org/linked-data/api/vocab#> .
@prefix rr: <http://www.w3.org/ns/r2rml#> .
@prefix sioct: <http://rdfs.org/sioc/types#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.

testblog:
  a lda:API ;
  lda:exposes testblog:blogs, testblog:blog .

testblog:blogs
  a lda:Resource ;
  api:uriTemplate "http://testblog.org/lodapi/blogs" ;
  lda:endpoint
  [ a lda:R2RMLSparqlEndpoint ;
    lda:has_r2rml_mapping testblog:bogsMapping ;
    lda:has_r2rml_graph rr:columnGraphIRI ];
  lda:has_operation lda:GET, lda:POST ;
  lda:named_graph_creation_mechanism testblog:blogsMappingUriMinter .

testblog:blogsMappingUriMinter
  a lda:NamedGraphCreationMechanism ;
  lda:uri_template "http://testblog.org/lodapi/blogs/{id}" ;
  lda:mapped_uri_parts
  [ lda:mapped_component_value "id" ;
    lda:uri_generator lda:UniqueIdInt ] .

testblog:blog
  a lda:Resource ;
  api:uriTemplate "http://testblog.org/lodapi/blogs/{id}" ;
  lda:endpoint
  [ a lda:R2RMLSparqlEndpoint ;
    lda:hasR2RMLMapping testblog:blogsMapping ;
    lda:hasR2RMLGraph rr:columnGraph ];
  lda:has_operation lda:GET, lda:PUT, lda:DELETE .

testblog:blogsMapping
  a rr:TriplesMap ;
  rr:logicalTable "blogs" ;
  rr:class sioct:Weblog ;
  rr:subjectMap [ a rr:IRIMap;
                  rr:column "id" ];
  rr:propertyObjectMap [ rr:property dc:creator;
                         rr:column "author" ];
  rr:propertyObjectMap [ rr:property dc:title;
                         rr:column "title" ];
  rr:propertyObjectMap [ rr:property dcterms:created;
                         rr:column "created_at" ;
                         rr:datatype xsd:dateTime ].
\end{lstlisting}


Esta descripci\'on describe dos aspectos b\'asicos del modelo de servicio:

\begin{itemize}
\item C\'omo se expone un conjunto de tripletes \textit{RDF} como un recurso \textit{REST} a trav\'es de la interfaz uniforme \textit{HTTP}.
\item C\'omo se transforman las peticiones \textit{HTTP} en consultas \textit{SPARQL} que cumplen con la sem\'antica que los principios arquitect\'onicos \textit{REST} asignan a las operaciones \textit{GET}, \textit{POST}, \textit{PUT} y \textit{DELETE} del protocolo \textit{HTTP}.
\end{itemize}

Distintos elementos del vocabulario propuesto permite especificar los componentes de estos dos aspectos b\'asicos del modelo de servicio.\\
En el caso de la asociaci\'on entre el servicio y la interfaz \textit{HTTP}, el vocabulario ofrece las siguientes propiedades:

\begin{itemize}

\item \textbf{\textit{uriTemplate}:} Un patr\'on para un \textit{URI} que designa a un conjunto de grafos con nombre que podr\'an ser accedidos mediante operaciones \textit{HTTP}.  Esta propiedad de la ontolog\'ia se ha reutilizado de la especificaci\'on de LD-API, as\'i como la sem\'antica del proceso de validaci\'on de un \textit{URI} con un patr\'on \textit{URI} como el identifica esta propiedad.
\item \textbf{\textit{has\_operation}:} Asocia al recurso una collecci\'on de operaciones \textit{HTTP} que ser\'an v\'alidas a la hora de acceder a los datos almacenados en el \textit{grafo con nombre} expuesto como un recurso. \textit{lda:GET}, \textit{lda:PUT}, \textit{lda:POST} y \textit{lda:DELETE} son posible operaciones v\'alidas para esta propiedad. Estas operaciones deber\'an ser interpretadas por cualquier implementaci\'on de la arquitectura de acuerdo con lo acordado en la propuesta de recomendaci\'on sobre el Protocolo \textit{SPARQL} \textit{HTTP} Uniforme para la Gesti\'on de Grafos \textit{RDF}. En el siguiente apartado de este documento definiremos la sem\'antica para cada una de las operaciones anteriores como determinadas consultas \textit{SPARQL} 1.1/Update, compatibles con la sem\'antica de la interfaz uniforme \textit{HTTP}, tal y como se estableci\'o en el c\'alculo formal para recursos \textit{REST} sem\'anticos descrito en el cap\'itulo anterior de este documento.

\end{itemize}

El segundo aspecto del modelo servicio, la forma en que los datos sem\'anticos del recurso son almacenados en un repositorio de grafos \textit{RDF}/\textit{SPARQL}, viene dado por las siguientes propiedades:

\begin{itemize}
\item \textbf{\textit{endpoint}:} El repositorio \textit{RDF} en el que se almacenar\'an los conjuntos de tripletes \textit{RDF} que dan soporte a la informaci\'on de los diferentes recursos expuestos por la \textit{API}. Este repositorio debe ser capaz de soportar el conjunto de especificaciones \textit{SPARQL 1.1 Update}.
\item \textbf{\textit{named\_graph\_creation\_mechanism}:} Esta propiedad describe como nuevos grafos con nombre ser\'an generados cuando nuevos recursos necesiten ser creados. El mecanismo debe especificar un patr\'on de \textit{URI} para el nuevo \textit{grafo con nombre} as\'i como las partes del patr\'on que ser\'an generados. Dos mecanismos est\'an definidos en nuestro modelo de servicio: \textit{lda:UniqueIdInt} y \textit{lda:UUID}. El primero de ellos genera un nuevo entero \'unico mientras que el segundo genera un nuevo identificador universal \'unico \textit{UUID}.
\end{itemize}

\subsection{Modelo de Procesamiento del Servicio}

Las implementaciones software del modelo aqu\'i propuesto deben aceptar peticiones \textit{HTTP} y procesarlas en un esquema de tres etapas como el siguiente:\

\begin{itemize}
\item Traducci\'on de la petici\'on \textit{HTTP} a una petici\'on \textit{SPARQL}.
\item Generaci\'on de nuevos identificadores para grafos con nombre, si es necesario, y ejecuci\'on de la consulta \textit{SPARQL} en el repositorio de grafos \textit{RDF}.
\item Serializaci\'on del grafo \textit{RDF} resultante como en la representaci\'on acordada entre cliente y servidor mediante el proceso de negociaci\'on de contenido descrito en el protocolo \textit{HTTP}.
\end{itemize}

En las siguientes secciones analizaremos como se puede transformar cada tipo de operaci\'on \textit{HTTP} en consultas \textit{SPARQL} sobre un repositorio de grafos \textit{RDF} de manera que se conserve la sem\'antica del protocolo \textit{HTTP}.

\subsubsection{Peticiones \textit{GET}}

Las peticiones  \textit{HTTP} \textit{GET} sobre un determinado \textit{URI} que identifica a un \textit{grafo con nombre} en el repositorio de grafos \textit{RDF}, se transforman en peticiones \textit{CONSTRUCT} \textit{SPARQL} que recuperan todos los tripletes almacenados en dicho \textit{grafo con nombre}.\\
La sintaxis de la consulta \textit{CONSTRUCT} \textit{SPARQL} se muestra en la tabla \ref{tabla6}.\\

\begin{table}
\vspace{2.4in}
\caption{Consulta \textit{SPARQL} para una peticion \textit{HTTP} \textit{GET}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla6}
\label{tabla6}
\end{table}


La sem\'antica de esta consulta \textit{SPARQL} coincide con la sem\'antica descrita en la propuesta de est\'andar \textit{Protocolo SPARQL HTTP Uniforme para la Gesti\'on de Grafos RDF} de la \textit{W3C}.\\
Adicionalmente, las peticiones \textit{GET} \textit{HTTP} pueden especificar dos par\'ametros \textit{\_pageSize} y textit{\_page} para modificar el n\'umero de tripletes en el grafo de destino que ser\'an recuperados por la consulta \textit{SPARQL} mediante el uso de las cl\'ausulas \textit{LIMIT} y \textit{OFFSET} del lenguaje \textit{SPARQL} al mismo tiempo que se ordena el conjunto de tripletes recuperados por sujeto, mediante el uso de la cla\'usula \textit{ORDER BY ?s}. Estos par\'ametros han sido propuestos en la propuesta \textit{LD-API} y permiten implementar paginaci\'on en el cliente \textit{HTTP} realizando la petici\'on.

\subsubsection{Peticiones \textit{POST}}

Las  peticiones \textit{HTTP} \textit{POST} para la creaci\'on de un nuevo recurso, son traducidas como peticiones \textit{INSERT DATA} del lenguaje \textit{SPARQL UPDATE} que insertar\'an los datos enviados en el cuerpo de la petici\'on \textit{HTTP} en un nuevo \textit{grafo con nombre} cuya \textit{URI} deber\'a generar el sistema, de acuerdo con el mecanismo de generaci\'on de identificadores elegido en la descripci\'on de la \textit{API}.\\
La sintaxis de la consulta \textit{SPARQL} UPDATE se muestra en la tabla \ref{tabla7}.\\

\begin{table}
\vspace{2.4in}
\caption{Consulta \textit{SPARQL} para una petici\'on \textit{HTTP} \textit{POST}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla7}
\label{tabla7}
\end{table}

Una consideraci\'on importante es la distinci\'on que se debe hacer entre el \textit{URI} generado para identificar el \textit{grafo con nombre} que se almacenar\'a en el repositorio de grafos \textit{RDF} y el \textit{URI} que identifica el recurso \textit{RDF} en los tripletes almacenados en el \textit{grafo con nombre} de acuerdo con la pr\'actica est\'andar a la que ha llegado la comunidad de Datos Enlazados Abiertos durante la discusi\'on de la relaci\'on entre recursos de informaci\'on y no recursos de informaci\'on \cite{fielding2005httprange}.\\
La siguiente tabla \ref{named_graph_vs_resource_uri} muestra las diferencias entre ambas \textit{URIs}.\\

\begin{table}
\centering
\caption{\textit{Grafos con nombre} frente a recursos \textit{RDF}.}
\vspace{5mm}
\label{named_graph_vs_resource_uri}
\begin{center}
\begin{tabular}{|l|l|}\hline
\textbf{\textit{Grafo con nombre}} & \textbf{\textit{Recurso RDF}} \\\hline
Identificado por un \textit{URI}. & Identificado por un \textit{URI}. \\
Recurso de informaci\'on. & No recurso de informaci\'on.\\
Identifica el \textit{grafo con nombre}. & Aparece dentro del \textit{grafo con nombre}.\\
Desreferenciable usando \textit{HTTP} & No desreferenciable usando \textit{HTTP}\\\hline
\end{tabular}
\end{center}
\end{table}


Sin embargo, ambas \textit{URIs} est\'an relacionadas, debiendo ser posible para un cliente web que se encuentre con la \textit{URI} del recurso formando parte de un triplete \textit{RDF} en otro grafo, seguir un enlace que desencadene una petici\'on \textit{HTTP} sobre la \textit{URI} del \textit{grafo con nombre} que almacena los datos del recurso.\\
Adem\'as, seg\'un los principios arquitect\'onicos \textit{REST}, la responsabilidad de generar la \textit{URI} del recurso \textit{HTTP}, lo que en nuestro caso significa generar un \textit{URI} para el \textit{grafo con nombre} y para el recurso \textit{RDF} almacenado en dicho grafo, depende del proveedor de la \textit{API}, no del cliente, por lo que la \textit{URI} del recurso \textit{RDF} no puede venir dada en los tripletes \textit{RDF} enviados por el cliente en la petici\'on \textit{HTTP}.\\
Nuestra soluci\'on a nuestro problema viene dada por un mecanismo que permite al cliente especificar un patr\'on de tripletes \textit{RDF} que se transformar\'a en el grafo \textit{RDF} final que se almacenar\'a en el repositorio \textit{RDF}, una vez que el servicio ha generado \textit{URIs} para el \textit{grafo con nombre} y el recurso \textit{RDF} mediante el mecanismo especificado en la descripci\'on de la \textit{API}.\\
El proceso es el siguiente:\\
\begin{itemize}

\item El cliente env\'ia una petici\'on \textit{HTTP} \textit{POST} a la \textit{URI} base de la colecci\'on de recursos, incluyendo un grafo \textit{RDF} en el cuerpo de la petici\'on, donde la \textit{URI} del recurso \textit{RDF} descrito en el grafo ha sido sustituido por un identificador de nodo an\'onimo \textit{RDF}. Adicionalmente, un par\'ametro \textit{\_self} se enviar\'a en la \textit{URI} de la petici\'on con el identificador del grafo an\'onimo usado para designar al recurso \textit{RDF} en el cuerpo de la petici\'on.
\item Si el grafo \textit{RDF} enviado en el cuerpo de la petici\'on incluye alg\'un triplete cuyo sujeto no es un identificador de nodo \textit{RDF} an\'onimo, el servicio debe devolver una respuesta de error \textit{HTTP} \textit{403 forbidden}.
\item El servicio genera una nueva \textit{URI} \textit{graph\_uri} para identificar al \textit{grafo con nombre} de acuerdo con el mecanismo especificado en la descripci\'on de la \textit{API}.
\item El servicio reemplaza el nodo an\'onimo especificada por el cliente en el patr\'on de tripletes \textit{RDF} para identificar el recurso \textit{RDF} por el \textit{hash URI} \cite{fielding2005httprange} \textit{graph\_uri\#self}.
\item El \textit{grafo con nombre} resultante, identificado por el \textit{URI} \textit{graph\_uri}, incluyendo la descripci\'on del recurso \textit{RDF} identificado por el \textit{URI} \textit{graph\_uri\#self} es almacenado en el repositorio \textit{RDF} mediante la consulta \textit{SPARQL Update} especificada en la tabla \ref{tabla7}.
\item Si la craci\'on del \textit{grafo con nombre}  resulta exitosa, el servicio debe devolver una respuesta \textit{HTTP} \textit{201 created} al cliente con una cabecera \textit{HTTP} \textit{location} con la \textit{URI} del nuevo \textit{grafo con nombre} creado.

\end{itemize}

El uso de un \textit{hash URI} para identificar al recurso \textit{RDF}, que usa como base el \textit{URI} utilizado para identificar al recurso \textit{HTTP} y al \textit{grafo con nombre} asociado, permite que clientes web que encuentran el \textit{URI} del recurso web enlazado en otro grafo \textit{RDF}, descubran el contenido del recurso \textit{RDF} sin desreferenciarlo directamente. Los \textit{hash URIs} no pueden ser directamente desereferenciadas. Cualquier intento de hacer una petici\'on \textit{HTTP} \textit{GET} a un \textit{hash URI} ser\'a interpretada por el servicio web como una petici\'on a la \textit{URI} base del \textit{hash URI}, en nuestro caso la \textit{URI} del \textit{grafo con nombre}, inici\'andose de esta manera el proceso de negociaci\'on de contenido \textit{HTTP} que finalmente llevar\'a al cliente a obtener una serializaci\'on concreta de la informaci\'on \textit{RDF} del recurso asociada al \textit{grafo con nombre}.

\subsubsection{Peticiones \textit{PUT}}

Las peticiones \textit{HTTP} \textit{PUT} son interpretadas por el servicio como un intento de reemplazar el contenido del recurso asociado por un nuevo contenido, en nuestro caso, un nuevo grafo \textit{RDF} que se almacenar\'a en el mismo \textit{grafo con nombre} asociado al recurso \textit{HTTP}.\\
Esta sem\'antica queda recogida en la combinaci\'on de consultas \textit{SPARQL Update} \textit{DROP SILENT} y \textit{INSERT DATA} sobre el repositorio de grafos \textit{RDF} en las que se traduce la petici\'on \textit{HTTP}. La tabla \ref{tabla8} muestra la sintaxis de dicha consulta.\\

\begin{table}
\vspace{2.4in}
\caption{Consulta \textit{SPARQL} para una petici\'on \textit{HTTP} \textit{PUT}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla8}
\label{tabla8}
\end{table}

El cuerpo de la petici\'on \textit{PUT} debe contener s\'olo tripletes que usan como sujeto el identificador del recurso \textit{RDF} \textit{graph\_uri\#self} o identificadores de nodos an\'onimos \textit{RDF}. El servicio debe cancelar el procesamiento de la petici\'on y devolver un c\'odigo de error \textit{HTTP} \textit{403 forbidden} si esta condici\'on no se cumple.

\subsubsection{Peticiones \textit{DELETE}}

Por \'ultimo, las peticiones \textit{HTTP} \textit{DELETE} se traducen como peticiones \textit{DROP GRAPH} \textit{SPARQL}, que suponen la eliminaci\'on del \textit{grafo con nombre} y toda la informaci\'on asociada a dicho grafo. La tabla \ref{tabla9} muestra la sintaxis de la petici\'on.\\

\begin{table}
\vspace{2.4in}
\caption{Consulta \textit{SPARQL} para una petici\'on \textit{HTTP} \textit{DELETE}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla9}
\label{tabla9}
\end{table}


El procesamiento de la petici\'on \textit{HTTP} \textit{DELETE} supone la destrucci\'on del recurso \textit{HTTP} identificado por el \textit{URI} del \textit{grafo con nombre}. Cualquier petici\'on adicional a la \textit{URI} del recurso \textit{HTTP} debe ser resuelta por el servicio con una respuesta \textit{HTTP} \textit{404 not found}.

\subsection{Serializaci\'on de resultados}

Tras obtener una respuesta exitosa desde el repositorio de grafos \textit{RDF} mediante una consulta \textit{SPARQL} la implementaci\'on de la \textit{API} debe devolver la informaci\'on recuperada al cliente mediante la representaci\'on acordada entre cliente y servidor mediante el proceso de negociaci\'on de contenido especificado en el protocolo \textit{HTTP}.\\
Los tipos de contenido soportados por la especificaci\'on LD-API deben ser tambi\'en soportados como tipos v\'alidos por implementaciones de esta \textit{API}.\\
Un tipo de datos de especial inter\'es es el tipo de datos \textit{JSON}. \textit{JSON} es el formato de datos elegido por la mayor\'ia de \textit{APIs} de datos en uso hoy en d\'ia. Con el fin de asegurar que la \textit{API} va a resultar \'util para desarrolladores web no familiarizados con la pila de tecnolog\'ias sem\'anticas, que simplemente est\'an recuperando informaci\'on a trav\'es de la \textit{API}, es importante ofrecer una representaci\'on de los grafos \textit{RDF} como objetos \textit{JSON} que pueda ser utilizada con facilidad por parte de estos desarrolladores.\\
\textit{JSON-LD} \cite{jsonld} es una representaci\'on que cumple estos criterios, gracias especialmente a una caracter\'istica denominada coerci\'on de tipos que permite codificar los grafos \textit{RDF} como objetos \textit{JSON} sencillos, con una propiedad adicional en la que se incluye la traducci\'on entre propiedades simples del objeto \textit{JSON} y los \textit{URIs} de las propiedades \textit{RDF} y tipos de los literales. Aquellos desarrolladores quen consuman la \textit{API} y no est\'en interesados en estas caracter\'isticas sem\'anticas de los resultados obtenidos, pueden ignorar esta propiedad adicional y tratar los resultados obtenidos como objetos \textit{JSON} sencillos. \textit{JSON-LD} es la codificaci\'on elegida para la implementaci\'on de nuestro modelo de servicio para cualquier petici\'on \textit{HTTP} seleccionando \textit{JSON} como el tipo de representaci\'on elegido para el recurso que se quiere recuperar, o enviando informaci\'on codificada como \textit{JSON}.\\
Por \'ultimo, la \textit{API} tambi\'en soporta un par de par\'ametros adicionales en las peticiones que permiten modificar la representaci\'on del recurso solicitado fuera del mecanismo de negociaci\'on de contenido \textit{HTTP}:

\begin{itemize}

\item \textit{\_callback}: Par\'ametro que puede ser pasado en la petici\'on y que forzar\'a al servicio a devolver una representaci\'on \textit{JSON-LD} del grafo \textit{RDF} asociado al recurso \textit{HTTP}, como el \'unico argumento de una invocaci\'on a una funci\'on \textit{JavaScript} cuyo nombre se pasa como valor del par\'ametro. Esta t\'ecnica, conocida como \textit{JSONP} \cite{jsonp}, permite a aplicaciones cliente \textit{JavaScript} que han sido iniciadas dentro de un navegador web, sobrepasar la limitaci\'on impuesta por la pol\'itica de seguridad de dominio \'unico activa en todos los navegadores web.\\
\item \textit{\_format}: Especifica un tipo de representaci\'on, tomando precedencia sobre el valor especificado en la cabecera accept de la petici\'on \textit{HTTP}.

\end{itemize}

La presencia de estos par\'ametros adicionales que imponen una sem\'antica adicional fuera de lo especificado por el protocolo \textit{HTTP} se justifica por la existencia de clientes web con un control limitado sobre el uso del protocolo, como aplicaciones \textit{JavaScript} siendo ejecutadas dentro de un navegador web.

\section{Components Software}

En las dos secciones anteriores de este cap\'itulo hemos descrito un modelo formal para la descripci\'on de la computaci\'on basada en servicios \textit{REST} sem\'anticos y un modelo arquitect\'onico y de servicio que permite transformar el modelo formal en una arquitectura web en el que un conjunto de peticiones \textit{HTTP} recibidas desde una interfaz de red se transforman en peticiones \textit{SPARQL} sobre un repositorio de grafos \textit{RDF}.\\
Sin embargo, el modelo arquitect\'onico descrito no establece la naturaleza de los componentes software concretos que se deben emplear para implementar dicha arquitectura. En particular no se especifica ning\'un detalle sobre el repositorio de grafos \textit{RDF}, m\'as all\'a de que debe soportar consultas \textit{SPARQL 1.1 Update}. Tampoco se ha mencionado c\'omo un cliente web puede gestionar la informaci\'on \textit{RDF} recuperada por el servicio para llevar a cabo una computaci\'on como la descrita en  nuestro c\'alculo formal.\\
Siguiendo el esp\'iritu de la comunidad de Datos Enlazados Abiertos, en esta secci\'on examinaremos la implementaci\'on que hemos llevado a cabo de dos componentes software que ofrecen alternativas para implementar esos componentes de la arquitectura propuesta usando las tecnolog\'ias m\'as comunes hoy en d\'ia en el desarrollo web: los sistemas gestores de bases de datos relaciones como repositiorios de grafos \textit{RDF} y aplicaciones \textit{JavaScript} ejecut\'andose dentro de un navegador web como clientes.

\subsection{Ejecuci\'on de consultas \textit{SPARQL 1.1 UPDATE} sobre datos relacionales.}

Como vimos en el cap\'itulo dedicado al estado del arte en este documento, una de las contribuciones de la comunidad de Datos Enlazados Abiertos ha sido el desarrollo de la propuesta de recomendaci\'on \textit{W3C} \textit{R2RML} \cite{r2rml} para la traducci\'on de datos relaciones en tripletes \textit{RDF}.\\
\textit{R2RML} consiste en un vocabulario gen\'erico que puede usarse para transformar un esquema relacional en tripletes \textit{RDF}. Una descripci\'on formal simplificada de la sintaxis de \textit{R2RML} se muestra en la tabla \ref{tabla10} como una gram\'atica \textit{EBNF}.\\

\begin{table}
\vspace{2.4in}
\caption{Sintaxis \textit{EBNF} de \textit{R2RML}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla10}
\label{tabla10}
\end{table}


Este modelo formaliza \textit{R2RML} como una traducci\'on de una colecci\'on de \textit{TableMappings} por cada tabla del esquema relacional que se intenta transformar en tripletes \textit{RDF}. Cada \textit{TableMapping} describe como los datos almacenados en la tabla se deben transformar en \textit{quads} \textit{RDF}, tripletes aumentados consistentes en sujeto, predica, objeto y un \textit{grafo con nombre}. Los componentes de un \textit{quad} son generados usando un \textit{TermMapping} definido en el \textit{TableMapping}.\\
Cada \textit{TermMapping} puede ser constante o variable. Los \textit{TermMappings} constantes asignan un \textit{URI} o literal \textit{RDF} para el valor de ese componente en el quad \textit{RDF} que se va a generar. Por su parte los \textit{TermMappings} variables pueden hacer referencia a una columna en el esquema relacional de donde el valor para el componente del \textit{quad} ser\'a extra\'ido.
Por su parte, el est\'andar \textit{SPARQL 1.1 Update} describe un lenguaje com\'un para la recuperaci\'on y modificaci\'on de grafos \textit{RDF} con una sintaxis similar a la del lenguaje de consulta relacional \textit{SQL}. La principal unidad usada para construir consultas \textit{SPARQL} son los \textit{QuadPatterns} que pueden ser aplicados sobre los tripletes almacenados en un grafo \textit{RDF}. La tabla \ref{tabla11} formaliza la noci\'on de un \textit{QuadPattern} con sus posible componentes, variables y constantes.\\

\begin{table}
\vspace{2.4in}
\caption{Sintaxis de los \textit{QuadPatterns}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{tabla11}
\label{tabla11}
\end{table}


\textit{R2RML} describe una transformaci\'on desde el modelo relacional al modelo de datos de \textit{RDF}. Con el fin de usar un documento \textit{R2RML} para construir una transformaci\'on gen\'erica de consultas \textit{SPARQL 1.1 Update} sobre un grafo \textit{RDF} en consultas \textit{SQL} sobre un esquema relacional, es necesario describir una transformaci\'on inversa a la especificada por dicho documento \textit{R2RML}. La figura \ref{figura2} muestra el proceso propuesto para llevar a cabo esa transformaci\'on, as\'i como el papel que el documento \textit{R2RML} juega en dicho proceso.\\

\begin{figure}
\vspace{2.4in}
\centering
\caption{Diferentes transformaciones codificadas en un documento \textit{R2RML}}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{figura2}
\label{figura2}
\end{figure}


El algoritmo descrito en la tabla \ref{alg1}, especifica en la funci\'on \textit{buildQuadMatchers} c\'omo llevar a cabo esa transformaci\'on inversa, generando un conjunto de \textit{QuadMatchers} para un conjunto de \textit{TripleMappers} de una descripci\'on \textit{R2RML} tomada como datos de entrada.\\

\begin{table}
\vspace{2.4in}
\caption{Algoritmo 1: Construcci\'on de \textit{QuadMatcher} para una tranformaci\'on \textit{R2RML}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{algoritmo1}
\label{alg1}
\end{table}

El listado del algoritmo mostrado en la tabla \ref{alg2} describe a su vez un procedimiento para comprobar si un \textit{QuadMatcher} es compatible con un \textit{QuadPattern} en una consulta \textit{SPARQL}.\\

\begin{table}
\vspace{2.4in}
\caption{Algoritmo 2: Procedimiento para comprobar si un \textit{QuadPattern} y un \textit{QuadMatcher} son compatibles.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{algoritmo2}
\label{alg2}
\end{table}

En las siguientes secciones describiremos algoritmos que permiten usar la compatibilidad entre \textit{QuadMatchers} y \textit{QuadPatterns} para ejecutar consultas \textit{SPARQL} \textit{SELECT}, \textit{INSERT DATA} y \textit{DELETE} sobre datos relacionales con una transformaci\'on \textit{R2RML} asociada. Estas operaciones son suficientes para implementar las consultas sobre el repositorio de grafos \textit{RDF} descritas en la secci\'on anterior de este cap\'itulo como transformaciones de las operaciones \textit{HTTP} sobre recursos \textit{REST} sem\'anticos en el modelo arquitect\'onico de servicios propuesto. Las consultas \textit{DROP GRAPH} usadas en dicho modelo pueden ser transformadas en operaciones \textit{DELETE} equivalentes donde todos los tripletes del grafo son eliminados.

\subsubsection{Consultas \textit{SPARQL} \textit{SELECT}}

La transformaci\'on de consultas \textit{SPARQL} \textit{SELECT} que proponemos se basa en el trabajo de \cite{chebotko2009semantics}, pero modificado para adaptarlo a la sintaxis y sem\'antica de las transformaciones \textit{R2RML}, donde algunas de las restricciones que impone \cite{chebotko2009semantics} son demasiado restrictivas. Un jemplo de estas restricciones es el hecho de que la tabla de donde se extraen los componentes de un quad \textit{RDF} debe ser \'unica, supuesto que no tiene por que ser v\'alido en una transformaci\'on \textit{R2RML}.\\
En el algoritmo de la tabla \ref{alg3} se muestra un procedimiento para transformar una consulta \textit{SPARQL SELECT} en un conjunto de \textit{QuadPatterns} que pueden usarase como la base de una consulta \textit{SQL SELECT} equivalente. Esto se lleva a cabo mediante la b\'usqueda de los \textit{QuadMatchers} compatibles con los \textit{QuadPatterns} que luego son unidos mediante una cl\'ausula \textit{UNION} de \textit{SQL}.

\begin{table}
\vspace{2.4in}
\caption{Algoritmo 3: Composici\'on de una consulta \textit{SELECT} para un \textit{QuadPattern} y un conjunto de \textit{QuadMatchers}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{algoritmo3}
\label{alg3}
\end{table}


\subsubsection{Consultas \textit{SPARQL} \textit{INSERT DATA}}

El la tabla \ref{alg4} contiene un algoritmo, que  muestra un procedimiento para la inserci\'on de un \textit{QuadPattern} con todos sus t\'erminos constantes en un esquema relacional con una transformaci\'on \textit{R2RML} asociada.\\

\begin{table}
\vspace{2.4in}
\caption{Algoritmo 4: Inserci\'on de un \textit{QuadPattern} para un conjunto de \textit{QuadMatchers}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{algoritmo4}
\label{alg4}
\end{table}


El principal problema que se debe solucionar para llevar a cabo la inserci\'on es que es posible encontrar m\'as de un \'unico \textit{QuadMatcher} compatible con el componente del QuadPattern donde llevar a cabo la inserci\'on.\\
Como muestra la figura \ref{figura3}, el algoritmo propuesto funciona construyendo un \'arbol con las posibles opciones de inserci\'on encontradas y despu\'es selecciona aquella potencial inserci\'on que minimiza una m\'etrica de coste descrita en el algoritmo de la tabla \ref{alg5}.

\begin{figure}
\vspace{2.4in}
\caption{Inserci\'on de dos \textit{quads}}
\vspace{5mm}
\includegraphics[width=0.5\textwidth]{figura3}
\label{figura3}
\end{figure}

\begin{table}
\vspace{2.4in}
\caption{Algoritmo 5: M\'etrica de coste.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{algoritmo5}
\label{alg5}
\end{table}


\subsubsection{Consultas \textit{SPARQL} \textit{DELETE WHERE}}

Para traducir consultas \textit{DELETE} \textit{SPARQL} en consultas \textit{SQL} equivalentes dada una transformaci\'on \textit{R2RML} de un esquema relacional, el primer paso consiste en transformar la cl\'ausula \textit{WHERE} de la consulta \textit{SPARQL} en una consulta \textit{SELECT} \textit{SQL} y una vez ejecutada usando el algoritmo previamente descrito \ref{alg3}, usar los resultados obtenidos para aplicarlos sobre el patr\'on de la cl\'ausula \textit{SELECT} para obtener el conjunto final de quads que deben ser eliminados del grafo \textit{RDF}.\\
El algoritmo de la tabla \ref{alg6} describe un procedimiento para eliminar los quads almacenados en un esquema relacional con una transformaci\'on \textit{R2RML} asociada. El algoritmo actualiza las columnas de las tablas asociadas por la transformaci\'on \textit{R2RML} a las propiedades \textit{RDF} y objetos con valores nulos, en vez de eliminar todo el quad, ya que la columna sujeto puede ser compartida por otros tripletes almacenados en la misma fila.\\

\begin{table}
\vspace{2.4in}
\caption{Algoritmo 6: Composici\'on de una consulta para eliminar un \textit{QuadPattern} para un conjunto de \textit{QuadMatchers}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{algoritmo6}
\label{alg6}
\end{table}


Tras eliminar todos los quads, la funci\'on removeEmptyRows elimina todas aquellas filas en las tablas de la transformaci\'on \textit{R2RML} donde todos los valores para las columnas propiedad y objeto tienen valores nulos.

\subsection{Un repositorio \textit{RDF} \textit{SPARQL 1.1 Update} para aplicaciones \textit{JavaScript}}
\label{sec_rdfstorejs}

En secciones anteriores de este cap\'itulo hemos expuesto c\'omo, desde el punto de vista formal, una computaci\'on basada en recursos \textit{REST} sem\'anticos involucra tanto a procesos recurso, que exponen datos sem\'anticos a trav\'es de canales identificados con \textit{URIs} como a procesos agente, que aunque no pueden ser accedidos directamente a trav\'es de \textit{URIs}, son capaces de consumir los datos sem\'anticos expuestos por los servicios y hacer avanzar la computaci\'on bas\'andose en los datos recuperados.\\
En la descripci\'on de la arquitectura que puede usarse para implementar el modelo te\'orico propuesto hemos hecho hincapi\'e en la parte servidor de la computaci\'on, sin entrar en los requisitos arquitecturales necesarios para implementar un proceso agente capaz de consumir y tomar decisiones basadas en la informaci\'on sem\'antica recuperada.\\
En principio, los \'unicos requisitos necesarios para implementar un proceso agente vienen dadas por los siguientes elementos b\'asicos:

\begin{itemize}
\item Soporte para el lado cliente del protocolo \textit{HTTP}.
\item Un mecanismo para almacenar grafos \textit{RDF} y ejecutar consultas \textit{SPARQL} sobre ellos.
\item Capacidad para reaccionar ante modificaciones en el grafo \textit{RDF} recuperado.
\end{itemize}

El soporte para el almacenamiento de grafos \textit{RDF} puede venir dado por el uso de un repositorio de grafos \textit{RDF} o un mecanismo que transforme un sistema gestor de bases de datos relacional en un repositorio \textit{RDF} con soporte para el lenguaje de consultas \textit{SPARQL}, como el que hemos expuesto anteriormente. Sin embargo, ning\'un tipo de repositorio \textit{RDF} de uso com\'un est\'a disponible para el que quiz\'as sea el m\'as com\'un de los entornos posibles para la ejecuci\'on de un proceso agente en una computaci\'on basada en recursos \textit{REST} sem\'anticos: el navegador web.\\
En esta secci\'on describiremos nuestra implementaci\'on de un repositorio \textit{RDF} con soporte para el lenguaje de consultas \textit{SPARQL 1.1 Update} as\'i como para notificaciones as\'incronas asociadas a modificaciones en el grafo \textit{RDF} almacenado, que puede usarse como un componente de aplicaciones \textit{JavaScript} que son ejecutadas dentro del navegador web en general y en particular para aplicaciones clientes consumiendo la \textit{API} descrita en la secci\'on dedicada a la descripci\'on de una arquitectura de servicios web expuesta en este documento.\\
El repositorio est\'a contenido en una biblioteca \textit{JavaScript} que puede usarse como la base de la capa de datos en aplicaciones \textit{JavaScript} complejas ejecut\'andose en el navegador. La biblioteca soporta no s\'olo el almacenamiento de grafos \textit{RDF} y la consulta de estos datos usando el lenguaje \textit{SPARQL 1.1 Update}, tambi\'en incluye funcionalidades para la deserializaci\'on de datos \textit{RDF} codificados usando formatos \textit{JSON}-LD, \textit{Turtle} y \textit{N3}.\\
La biblioteca se ha dise\~nado para tomar ventaja de las caracter\'isticas modernas que incluyen las \'ultimas versiones de los navegadores web, si se encuentran disponibles, como la ejecuci\'on multi-hilo mediante el soporte para \textit{WebWorkers} \cite{hicksonweb} y el almacenamiento de datos persistentes usando la funcionalidad de Web Storage \cite{webstorage}.\\
Otra interesante capacidad de la biblioteca consiste en la posibilidad de registrar funciones asociadas a eventos sobre el grafo, que ser\'an invocadas por el repositorio cuando una modificaci\'on en el grafo \textit{RDF} satisfaga las condiciones asociadas al evento.\\
Por \'ultimo, la implementaci\'on \textit{JavaScript} del repositorio permite su ejecuci\'on no s\'olo dentro del navegador web, sino tambi\'en en el lado servidor mediante una plataforma para la ejecuci\'on de aplicaciones \textit{JavaScript} conocida como \textit{Node.JS} que ha ganado una gran popularidad recientemente entre los desarrolladores de aplicaciones web. La figura \ref{figura4} muestra los principales componentes de la biblioteca que implementa el repositorio \textit{RDF}.

\begin{figure}
\vspace{2.4in}
\centering
\caption{Principales componentes del repositorio \textit{RDF}.}
\vspace{5mm}
\includegraphics[width=0.8\textwidth]{figura4}
\label{figura4}
\end{figure}


\subsubsection{Almacenamiento persistente y no persistente}

El almacenamiento de datos en memoria no persistente de la biblioteca se basa en un modelo conceptual en el que todo los quads \textit{RDF} se almacenan en una \'unica tabla y son indexados usando un conjunto de estructuras de datos \textit{b-tree} que aumentan la eficiencia de las consultas de recuperaci\'on de datos.\\
Estos \'indices est\'an formados por el m\'inimo n\'umero de \'indices necesarios para cubrir los diferentes patrones presentes en las consultas \textit{SPARQL} formadas por patrones b\'asicos de grafo (\textit{BGP}) \cite{yars}.\\
En el almacenamiento persistente, hemos hecho uso de la \textit{API} de Web Storage \cite{webstorage}. Esta \textit{API} define un objeto \textit{JavaScript} \textit{localStorage} que recubre un mapa persistente donde se pueden almacenar pares clave-valor como objetos \textit{String} \textit{JavaScript}. La capacidad de almacenamiento de este mapa es limitado, siendo 15 MB el l\'imite por defecto presente en la mayor\'ia de los navegadores web modernos. La tabla de datos y los \'indices son almacenados en esta capa de persistencia usando un mecanismo propio que permite la serializaci\'on eficiente de los componentes de los \textit{quads} \textit{RDF} como objetos \textit{JSON}. Al mismo tiempo, un componente de \textit{cach\'e} permite un acceso eficiente a los datos almacenados reduciendo el n\'umero de b\'usquedas necesarios en la capa de persistencia.

\subsubsection{Procesamiento de consultas \textit{SPARQL}}

La ejecuci\'on de una consulta \textit{SPARQL} sobre un grafo \textit{RDF} almacenado en el repositorio se realiza en dos pasos diferenciados por la biblioteca.\\
En primer lugar se lleva a cabo el an\'alisis del texto de la consulta \textit{SPARQL} que es transformado en un objeto \textit{JSON} complejo que representa el \'arbol de sintaxis abstracta para la consulta. Este paso se ha implementado usando una \textit{Parsing Grammar Expression} (\textit{PEG}) \cite{pegs} con capacidad para analizar l\'exicamente consultas \textit{SPARQ 1.1 Update} y documentos \textit{Turtle}.\\
A continuaci\'on, el \'arbol de sintaxis abstracta es transformado en un objeto \textit{JSON} diferente que contiene la representaci\'on de una expresi\'on en el \'algebra \textit{SPARQL} \textit{cyganiak2005relational} equivalente de acuerdo con la sem\'antica para \textit{SPARQL} estandarizada por la \textit{W3C}.\\
Esta expresi\'on algebraica ser\'a el objeto de procesamiento por el motor de ejecuci\'on \textit{SPARQL} del repositorio, que realizar\'a las consultas adecuadas sobre la tabla l\'exica y los \'indices del repositorio para generar los resulados finales de la consulta y serializarlos en el formato deseado por el cliente.

\subsubsection{Ejecuci\'on multi-hilo}

Las aplicaciones \textit{JavaScript} que se ejecutan en el navegador se encuentran limitadas a un \'unico hilo de ejecuci\'on. Un posible mecanismo para sobrellevar esta limitaci\'on se encuentra en la \textit{API} de \textit{WebWorkers} \cite{hicksonweb} presente en las \'ultimas versiones de la mayor\'ia de navegadores web. Esta \textit{API} hace posible ejecutar c\'odigo \textit{JavaScript} en un hilo de ejecuci\'on diferente con severas restricciones en cuanto a las capacidades del navegador que ese hilo puede utilizar. El hilo principal de la aplicaci\'on y estos hilos especiales y restringidos se comunican mediante un protocolo de paso de mensajes.\\
La biblioteca que implementa el repositorio se beneficia del soporte para \textit{WebWorkers}, si est\'a disponible, para ejecutar consultas \textit{SPARQL} de una manera concurrente en un conjunto de hilos restringidos. Desde el punto de vista de la arquitectura de la biblioteca, la interfaz entre cliente y repositorio est\'a implementada en un componente que sirve de fachada al sistema. Si capacidad para usar \textit{WebWorkers} es detectada en el navegador, un conjunto de hilos restringidos son creados y las consultas se distribuyen entre ellos. Cuando el procesamiento de una consulta ha finalizado, el resultado es recibido por el componente fachada que finalmente env\'ia los resultados al cliente. Si el soporte para \textit{WebWorkers} no est\'a presente, la l\'ogica presente en los hilos restringidos es cargada por el componente fachada en el hilo principal y se procede a ejecutar las consultas \textit{SPARQL} de una manera secuencial.\\
Como ya hemos comentado, los hilos creados a trav\'es de la \textit{API} \textit{WebWorkers} se encuentran muy limitados, no pudiendo, por ejemplo, realizar peticiones web o acceder a la \textit{API} \textit{WebStorage}. Cuando un hilo restringido necesita llevar a cabo cualquiera de estas operaciones, un mensaje debe ser enviado al hilo principal para que la lleve a cabo y env\'ie el resultado al hilo restringido de modo que pueda continuar con su ejecuci\'on.

\subsubsection{\textit{API} de eventos}

Las aplicaciones \textit{JavaScript} presentan un modelo de ejecuci\'on reactivo, donde el c\'odigo escrito de forma as\'incrona, es ejecutado como respuesta a eventos que tienen lugar en la aplicaci\'on.\\
Nuestra implementaci\'on de un repositorio \textit{RDF} para \textit{JavaScript} hace posible usar este modelo de ejecuci\'on as\'incrono, permitiendo que la aplicaci\'on registre funciones que ser\'an ejecutadas cuando un determinado evento suceda en el grafo \textit{RDF} almacenado en \'el.\\
Este modelo de ejecuci\'on tambi\'en se encuentra pr\'oximo al modelo te\'orico que hemos presentado donde diferentes procesos se comunican a trav\'es de un espacio de tripletes a trav\'es de operaciones de lectura y escritura sobre \'el.\\
El mecanismo de eventos funciona a dos niveles de abstracci\'on diferentes: al nivel de las consultas \textit{SPARQL} y al nivel de los nodos \textit{RDF}.\\
Desde el punto de vista puramente \textit{SPARQL}, el cliente puede subscribirse a una consulta \textit{SPARQL} que ser\'a evaluada continuamente por el repositorio. Cada vez que una modificaci\'on del grafo \textit{RDF} modifique los resultados de la consulta, la funci\'on subscrita a la consulta ser\'a invocada de nuevo con el nuevo resultado para la misma.\\
Al nivel de los nodos \textit{RDF}, un cliente puede subscribirse a un nodo \textit{RDF} particular, identificado por un \textit{URI}, siendo notificado con el nuevo estado del nodo cada vez que una modificaci\'on del grafo \textit{RDF} haga que los contenidos o la misma presencia del nodo en el grafo cambie.